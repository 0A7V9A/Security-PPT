CORE SECURITY
Exploiting Adobe Flash Player in the era of Control Flow Guard Francisco Falcon (@fdfalcon) Black Hat Europe 2015 November 12-13, 2015
PAGE

About me
PAGE 2

About me
· Exploit Writer for Core Security. · From Argentina. · Interested in the usual stuff: reverse engineering, vulnerability
research, exploitation...
PAGE 3

Agenda
PAGE 4

Agenda
· Overview of Control Flow Guard. · CVE-2015-0311: Flash Player UncompressViaZlibVariant UAF · Leveraging Flash Player's JIT compiler to bypass CFG · How Microsoft hardened Flash Player's JIT compiler · Data-only attacks against Flash Player
· Gaining unauthorized access to the camera & microphone · Gaining unauthorized read access to the local filesystem · Arbitrary code execution without shellcode nor ROP
· Demos · Conclusions/Q&A
PAGE 5

Overview of Control Flow Guard
PAGE 6

Overview of CFG
· Control Flow Guard checks that the target address of an indirect call is one of the locations identified as "valid" at compile time.
· Compiler support: Visual Studio 2015 · OS support:
· Windows 8.1 Update 3 · Windows 10
PAGE 7

Overview of CFG
· Windows 8 / 8.1 / 10: Flash Player is integrated into the OS. · Compiled by Microsoft using CFG-aware Visual Studio 2015. · Recommended readings:
· "Windows 10 Control Flow Guard Internals" by MJ0011, Power of Community 2014 conference.
· "Exploring Control Flow Guard in Windows 10" by Jack Tang, Trend Micro.
PAGE 8

29000+ guarded indirect calls in Flash Player
PAGE 9

CVE-2015-0311 Overview
PAGE 10

CVE-2015-0311 Overview
· Use-After-Free in Adobe Flash Player when decompressing a ByteArray with corrupted zlib data.
· Buggy function is UncompressViaZlibVariant() (core/ByteArrayGlue.cpp)
· Buggy function frees a buffer while leaving a reference to it in the ApplicationDomain.currentDomain.domainMemory global property.
PAGE 11

CVE-2015-0311 Overview
· Memory hole left by the freed buffer can be reclaimed to allocate another object.
· We end up allocating a Vector object in that memory hole. · domainMemory is supposed to reference an uint8_t[] array. · Instead it's pointing to a Vector object.
PAGE 12

CVE-2015-0311 Overview
PAGE 13

CVE-2015-0311 Overview
PAGE 14

CVE-2015-0311 Overview
Exploitation approach before CFG (e.g. Windows 7): · Overwrite the length of the Vector with 0xffffffff Æ read
from/write to any memory address · overwrite vtable field of the Vector object with address of
ROP chain · call the_vector.toString() Æ start ROP chain!
PAGE 15

CVE-2015-0311 Overview
Exploitation approach after CFG (e.g. Windows 8.1 Update 3): · Overwrite the length of the Vector with 0xffffffff Æ read
from/write to any memory address · overwrite vtable field of the Vector object with address of
ROP chain · call the_vector.toString() Æ attempt to hijack execution flow
is detected, application exits before gaining code execution
PAGE 16

Before...
PAGE 17

... and after
___guard_check_icall_fptr points to ntdll!LdrpValidateUserCallTarget
PAGE 18

Control flow hijacking attempt detected!
Int 29h: nt!_KiRaiseSecurityCheckFailure [http://www.alex-ionescu.com/?p=69]
PAGE 19

Approaches
PAGE 20

Approaches
· Overwrite a return address on the stack. · Take advantage of non-CFG module in the same process. · Find indirect calls that weren't guarded for some reason.
PAGE 21

Approaches
So, ideally we want ... · An Indirect call... · ... that isn't protected by CFG · ... that can be explicitly triggered in a straightforward way · ... which has a CPU register pointing nearby our data when the
controlled function pointer is called.
PAGE 22

Approaches
· Control Flow Guard protects indirect calls that could be identified at compile time.
· Are there any indirect calls in Flash Player which are not generated at compile time?
PAGE 23

Approaches
· Control Flow Guard protects indirect calls that could be identified at compile time.
· Are there any indirect calls in Flash Player which are not generated at compile time?
· Æ Yes, there are!
PAGE 24

Flash JIT compiler
· Flash Player JIT compiler to the rescue! · JIT-generated code does contain indirect calls. · Since this code is generated at runtime, it doesn't benefit
from Control Flow Guard.
PAGE 25

Flash JIT compiler
Flash JIT compiler has been proven helpful for exploitation in the past: · "Pointer inference and JIT spraying" by Dion Blazakis (2010) · "Flash JIT - Spraying info leak gadgets" by Fermín Serna (2013)
PAGE 26

Leveraging the JIT compiler to bypass CFG
· ByteArray object containing our ROP chain · ByteArray object + 0x8 = pointer to VTable object
[core/VTable.h]
PAGE 27

Leveraging the JIT compiler to bypass CFG
· VTable object contains lots of pointers to MethodEnv objects [core/MethodEnv.h]:
PAGE 28

Leveraging the JIT compiler to bypass CFG
· This is the MethodEnv object stored at VTable_object + 0xD4:
· Second DWORD is a function pointer (0x601C0A70). · This function pointer is called through an UNGUARDED
INDIRECT CALL from JIT-generated code!
PAGE 29

Leveraging the JIT compiler to bypass CFG
· UNGUARDED INDIRECT CALL from JIT-generated code:
· Can be reliably triggered by calling the toString() method on the ByteArray object containing our ROP chain.
PAGE 30

Exploitation
· We know how to easily trigger an indirect call that isn't guarded by CFG.
· We need to put a pointer to a fake MethodEnv object at VTable_object + 0xD4.
· Additional benefit: we get ECX to point to our ROP chain at the moment the unguarded CALL EAX is executed Æ easy to pivot the stack
PAGE 31

Expected state
PAGE 32

Modified state
PAGE 33

Exploitation
Overwriting VTable_object + 0xd4 with a pointer to the fake MethodEnv object (ROP chain) from ActionScript:
(address_of_rop_chain is shifted 3 times to the right because it has type uint, and AVM stores uint values shifted 3 times to the left and OR'ed with 6 [Integer tag])
PAGE 34

Exploitation
Finally, we call the toString() method on the ByteArray object (which at this point was already stored at this.the_vector[0] in order to leak its address)
PAGE 35

Current status
· Microsoft killed this CFG bypass technique in Flash 18.0.0.194 (KB3074219, June 2015) · Google has hardened the Vector object In Flash 18.0.0.209 (July 2015); additional improvements in Flash 18.0.0.232 (August 2015).
PAGE 36

How Microsoft hardened Flash Player's JIT compiler
PAGE 37

JIT hardening
· Main JIT hardening measures:
· When JIT code is the source of an indirect call Æ JIT compiler now emits a call to the CFG validation function before indirect calls.
· When JIT code is the destination of an indirect call Æ Uses new memory management flags (PAGE_TARGETS_INVALID, PAGE_TARGETS_NO_UPDATE) and functions (SetProcessValidCallTargets).
PAGE 38

No more unguarded indirect calls in JIT code
PAGE 39

JIT hardening
From the "Memory Protection Constants" article in MSDN:
· Default behavior for executable pages allocated via VirtualAlloc is to mark all locations in that memory region as valid call targets for CFG.
· Default behavior for VirtualProtect, when changing protection to executable, is to mark all locations in that memory region as valid call targets for CFG.
· Applies to PAGE_EXECUTE, PAGE_EXECUTE_READ, PAGE_EXECUTE_READWRITE, PAGE_EXECUTE_WRITECOPY permissions.
PAGE 40

JIT hardening
· VirtualAlloc(..., PAGE_EXECUTE_*, ...) Æ all locations within that region are valid call targets for CFG.
· VirtualProtect(..., PAGE_EXECUTE_*, ...) Æ all locations within that region are valid call targets for CFG.
· Looks like a decision to avoid breaking non CFG-aware JIT compilers.
PAGE 41

JIT hardening
· Non CFG-aware JIT compilers pseudo-code:
· VirtualAlloc(..., PAGE_READWRITE, ...) · Write code to that memory region · VirtualProtect(..., PAGE_EXECUTE_READ, ...) · Call JIT'ed code
PAGE 42

JIT hardening
· Windows 10 introduced two new memory protection constants for VirtualAlloc/VirtualProtect.
· PAGE_TARGETS_INVALID (0x40000000) · PAGE_TARGETS_NO_UPDATE (0x40000000) https://msdn.microsoft.com/enus/library/windows/desktop/aa366786%28v=vs.85%29.aspx
PAGE 43

JIT hardening
· PAGE_TARGETS_INVALID (to be used with VirtualAlloc): Sets all locations in the pages as invalid targets for CFG. Used along with any execute page protection. Any indirect call to locations in those pages will fail CFG checks.
PAGE 44

JIT hardening
· PAGE_TARGETS_NO_UPDATE (to be used with VirtualProtect): Pages in the region will not have their CFG information updated while the protection changes. For example, if the pages in the region were allocated using PAGE_TARGETS_INVALID, then the invalid information will be maintained while the page protection changes. This flag is only valid when the protection changes to an executable type (PAGE_EXECUTE_*).
PAGE 45

JIT hardening
SetProcessValidCallTargets
Provides CFG with a list of valid indirect call targets and specifies whether they should be marked valid or not. The valid call target information is provided as a list of offsets relative to a virtual memory range (start and size of the range). · https://msdn.microsoft.com/en-
us/library/windows/desktop/dn934202%28v=vs.85%29.aspx
PAGE 46

JIT hardening
PAGE 47

PAGE 48

Read-only function pointer

JIT hardening
· CFG-aware JIT compilers (e.g. Flash on Windows 10) pseudocode:
· VirtualAlloc(..., PAGE_READWRITE, ...) · Write code to that memory region · VirtualProtect(PAGE_EXECUTE_READ|PAGE_TARGETS_NO_UPDATE) · SetProcessValidCallTargets() · Call JIT'ed code
PAGE 49

PAGE 50

PAGE 51

PAGE 52

Alternative payloads
PAGE 53

What if hijacking the execution flow of the program becomes really,
really hard?
PAGE 54

Data-only attacks
· Data-only attacks to the rescue! · Forget about gaining execution by injecting native shellcode
or using ROP; let's hack the vulnerable software by modifying its internal state instead!
PAGE 55

Data-only attacks: related work
· "Easy local Windows Kernel exploitation" (César Cerrudo, Black Hat 2012)
· "Write once, pwn anywhere" (a.k.a. Vital Point Strike, tombkeeper, Black Hat 2014)
· "Data-only Pwning Microsoft Windows Kernel: Exploitation of Kernel Pool Overflows on Microsoft Windows 8.1" (Nikita Tarakanov, Black Hat 2014)
PAGE 56

Data-only attacks
Data-only payloads to be discussed in this section: · Gaining access to the camera and microphone without user
authorization. · Escalating the sandbox under which the SWF file is loaded:
from the restricted REMOTE sandbox to the privileged LOCAL TRUSTED sandbox. · Executing arbitrary commands without code injection or ROP.
PAGE 57

The SecuritySettings object
· Flash Player holds a SecuritySettings object in heap memory · Some interesting fields:
· SecuritySettings_object + 0x4 (size:4): sandboxType · SecuritySettings_object + 0x49 (size:1): is_camera_activated
· Although located on the heap, this SecuritySettings object can be easily found by using a global (static) variable as the starting point -
PAGE 58

The SecuritySettings object
Locating the SecuritySettings object in memory: 1. Find this global variable in Flash.ocx (named global_status by
me):
PAGE 59

The SecuritySettings object
Locating the SecuritySettings object in memory:
2. Follow some pointers... global_status Æ
+ 0x0 Æ + 0x78 Æ + 0x30 Æ + 0x9C Æ SecuritySettings object!
[This chain of pointers may vary across Flash versions, operating systems (Win 8.1 vs 10) and architecture (32-bit vs 64-bit)]
PAGE 60

Gaining (unauthorized) access to the camera & mic
PAGE 61

Gaining (unauthorized) access to the camera & mic
· When a SWF Flash file tries to access the camera or microphone, the user is prompted with this dialog:
PAGE 62

Gaining (unauthorized) access to the camera & mic
From the flash.media.Camera ActionScript class:
PAGE 63

Gaining (unauthorized) access to the camera & mic
PAGE 64

Gaining (unauthorized) access to the camera & mic
Steps to activate the camera without user authorization: 1. Find the SecuritySettings object in memory. 2. Set the byte at SecuritySettings_object + 0x49 to 1! Activating the camera also grants access to the microphone -
PAGE 65

Gaining (unauthorized) access to the camera & mic
Activating the camera from ActionScript code:
PAGE 66

Gaining (unauthorized) access to the camera & mic
Capture a frame from the camera and upload it to our server!
PAGE 67

From Remote sandbox to Local Trusted sandbox
PAGE 68

From Remote sandbox to Local Trusted sandbox

Flash Player loads SWF files into different sandboxes according to their origin:

· Local-trusted sandbox
· Local-with-network sandbox · Local-with-filesystem sandbox
· Remote sandbox

More privileged Less privileged

PAGE 69

From Remote sandbox to Local Trusted sandbox
Current sandbox can be queried via the flash.system.Security.sandboxType property:
PAGE 70

From Remote sandbox to Local Trusted sandbox
· The current sandbox is hold in a field of the same SecuritySettings object shown before.
· sandboxType = 0: Remote · sandboxType = 1: Local-with-filesystem · sandboxType = 2: Local-with-network · sandboxType = 3: Local-trusted
PAGE 71

From Remote sandbox to Local Trusted sandbox
· The current sandbox is hold in a field of the same SecuritySettings object shown before.
· Moving from the limited Remote sandbox to the privileged Local Trusted sandbox is as simple as this:
1. Find the SecuritySettings object in memory. 2. Set the dword at SecuritySettings_object + 0x4 to 3!
PAGE 72

From Remote sandbox to Local Trusted sandbox
Moving from the limited Remote sandbox to the privileged Local Trusted sandbox from ActionScript code:
PAGE 73

From Remote sandbox to Local Trusted sandbox
· Escalating to the Local Trusted sandbox grants our SWF file access to both local files and the network.
· So we can exfiltrate arbitrary files through Flash!
PAGE 74

From Remote sandbox to Local Trusted sandbox
Reading a local file:
PAGE 75

From Remote sandbox to Local Trusted sandbox
Uploading the contents of the local file to our server:
PAGE 76

Executing commands without shellcode nor ROP
PAGE 77

Executing commands without shellcode nor ROP
· Control Flow Guard checks that the target address of an indirect call is one of the locations identified as valid.
· It is possible to abuse legit, "safe" locations to do something useful from an attacker's perspective...
· ...for example, to execute arbitrary commands without even injecting code nor using ROP.
· Technique overlapped with Yuki Chen, who presented it first at the SyScan 2015 conference.
PAGE 78

Executing commands without shellcode nor ROP
· The WinExec function from the kernel32.dll library is recognized as a valid destination for indirect calls at compile time.
· Nothing stops us from replacing the vtable of an object with a fake vtable containing a pointer to kernel32!WinExec, since this function is a totally legit destination for indirect calls.
· If we are also able to control/overwrite the first argument that is passed to the virtual method being invoked, that means that we can do WinExec("some_program.exe")!
PAGE 79

Executing commands without shellcode nor ROP
· When calling the toString() method on a Vector object, the 2nd function pointer of its vtable is called, receiving the dword stored at Vector_object + 0x8 as its first argument.
· We can use our write primitive to overwrite the memory at the address pointed by Vector_object + 0x8 with a string of the command we want to execute (e.g. "calc").
PAGE 80

Executing commands without shellcode nor ROP
· We use our read primitive to leak the address of the kernel32!WinExec function. We store this address at our fake_vtable + 0x4.
· Then we use our write primitive to replace the vtable pointer of the Vector object with the address of our fake vtable.
· Finally, we invoke the toString() method of the crafted Vector object, which results in a totally legit call to WinExec("calc"). We get code execution without even having injected native shellcode nor using ROP!
PAGE 81

Original state
PAGE 82

Crafted state
PAGE 83

Demo Time!
PAGE 84

Conclusions
PAGE 85

Black Hat Sound Bytes
· All in all, CFG may be an effective mitigation to raise the costs of exploiting memory corruption vulnerabilities, as long as:
· every module in the process is CFG-aware. · code generated at runtime is properly protected
· JIT compilers are likely to undermine the effectiveness of CFG in other software, unless special effort is made to harden them.
· Data-only attacks are really hard to detect/prevent. We may see an increase of this kind of attacks as modification of control flow becomes harder.
PAGE 86

Thank you!
Questions?

@fdfalcon
PAGE 87

ffalcon@coresecurity.com

