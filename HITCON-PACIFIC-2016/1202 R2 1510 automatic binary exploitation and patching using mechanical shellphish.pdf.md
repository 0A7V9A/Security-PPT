Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish
Antonio Bianchi antoniob@cs.ucsb.edu
University of California, Santa Barbara (UCSB)
HITCON Pacific December 2nd, 2016

Shellphish
 A team of security enthusiasts  Do research in system security

 Play security competitions (CTF)

 Mainly students from University of California, Santa Barbara

 More info:  "A Dozen Years of Shellphish" https://youtu.be/APY2SsBde1U

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

2

CGC
 A fully automated CTF competition  Organized by DARPA  No Human intervention

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

3

CGC ­ Timeline

QuOanlliifnieceavteinotn, J!une 2015

FinLaivlese!vent, August 2016

2014

Shellphish signs up!

Open source release!

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

4

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

5

CGC ­ How the game worked

 Round-based game
 Organizers' servers
provide:
 Binaries
 Linux-like, Intel x86, limited syscalls
 Console (stdin/stdout)  Compiled C programs 
no source code  Contain one or more
vulnerabilities
 Network traffic
 Collected during previous rounds

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

6

CGC ­ How the game worked
 Teams provide  Patched binaries  Attacks

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

7

CGC ­ How the game worked
 Organizers's servers evaluate  Attacks vs. Patched binary

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

8

CGC ­ How the game worked
 Organizers' servers send back  Scores  Patched binaries from adversarial teams

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

9

CGC ­ How the game worked
 Before the game  Teams can set up their servers

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

10

CGC ­ How the game worked
 During the game (10h)  "Certified air gap"  Scores are the only data exiting

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

11

How to play?

Automatic Binary Exploitation

Automatic Binary Patching

Infrastructure

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

13

How to play?
Automatic Binary Exploitation

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

14

Two types of exploits

Type 1 control general purpose register
eax, ebx, ecx, edx, esi, edi, esp
control instruction pointer
eip

Type 2 leak memory from flag page

0x4347c000 0x4347d000
4 consecutive bytes needed

FLAG

 Arbitrary code execution

 Information leak (Heartbleed, ASLR base address leak, ...)

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

15

Exploitation pipeline (simplified)

Vulnerable Binaries

Driller
(fuzzing + symbolic execution)

Testcases

Network Traffic

Rex
(Type1 exploits)
Colorguard
(Type2 exploits)

Exploit Compiler

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

Exploit
16

Driller

 Execute "the most" of the program  Find good inputs to the binary

v1 = user_input1() v2 = user_input2()
if(v1 < 10){ if (v1 == 3){ foo() }else if(v1 == 7){ bar()
} }else{
if((v1^2 - 19087925*v1)==57263784){ function_pointer = v2 + 300 function_pointer()
} }

Try many different inputs: "1", "2", "3", "4", "5", "7", "8", ...

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

17

Driller

 Execute "the most" of the program  Find good inputs to the binary

v1 = user_input1() v2 = user_input2()
if(v1 < 10){ if (v1 == 3){ foo() }else if(v1 == 7){ bar()
} }else{
if((v1^2 - 19087925*v1)==57263784){ function_pointer = v2 + 300 function_pointer()
} }

"3" and "7" are "good" testcases: they reach new code locations

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

18

Driller

 Execute "the most" of the program  Find good inputs to the binary

v1 = user_input1() v2 = user_input2()
if(v1 < 10){ if (v1 == 3){ foo() }else if(v1 == 7){ bar()
} }else{
if((v1^2 - 19087925*v1)==57263784){ function_pointer = v2 + 300 function_pointer()
} }

This is hard to reach randomly

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

19

Driller

 Execute "the most" of the program  Find good inputs to the binary

v1 = user_input1() v2 = user_input2()

if(v1 < 10){

if (v1 == 3){

foo()

}else if(v1 == 7){

bar()

}

}else{

if((v1^2 - 19087925*v1)==57263784){

function_pointer = v2 + 300

function_pointer()

Target

}

}

We can use "symbolic tracing"

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

20

Driller

 Execute "the most" of the program  Find good inputs to the binary

v1 = user_input1() v2 = user_input2()

if(v1 < 10){

if (v1 == 3){

foo()

}else if(v1 == 7){

bar()

}

}else{

if((v1^2 - 19087925*v1)==57263784){

function_pointer = v2 + 300

function_pointer()

Target

}

}

We can use "symbolic tracing" Contraints:
- v1 = user_input1()

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

21

Driller

 Execute "the most" of the program  Find good inputs to the binary

v1 = user_input1() v2 = user_input2()

if(v1 < 10){

if (v1 == 3){

foo()

}else if(v1 == 7){

bar()

}

}else{

if((v1^2 - 19087925*v1)==57263784){

function_pointer = v2 + 300

function_pointer()

Target

}

}

We can use "symbolic tracing" Contraints:
- v1 = user_input1 - not (v1 < 10)

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

22

Driller

 Execute "the most" of the program  Find good inputs to the binary

v1 = user_input1() v2 = user_input2()

if(v1 < 10){

if (v1 == 3){

foo()

}else if(v1 == 7){

bar()

}

}else{

if((v1^2 - 19087925*v1)==57263784){

function_pointer = v2 + 300

function_pointer()

Target

}

}

We can use "symbolic tracing" Contraints:
- v1 = user_input1() - not (v1 < 10) - v1^2 - 19087925*v1 == 57263784

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

23

Driller

 Execute "the most" of the program  Find good inputs to the binary

v1 = user_input1() v2 = user_input2()

if(v1 < 10){

if (v1 == 3){

foo()

}else if(v1 == 7){

bar()

}

}else{

if((v1^2 - 19087925*v1)==57263784){

function_pointer = v2 + 300

function_pointer()

Target

}

}

We can use "symbolic tracing" Contraints:
- v1 = user_input1() - not (v1 < 10) - v1^2 - 19087925*v1 == 57263784
Solve:
- user_input1 = 0x1234238

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

24

Driller ­ AFL + angr

Fuzzing: AFL
good at finding solutions for general
inputs

Symbolic Execution:
angr
good at find solutions for specific inputs

Driller: Augmenting fuzzing through selective symbolic execution. N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang, J. Corbetta, Y. Shoshitaishvili, C. Kruegel, and G. Vigna. at NDSS 2016

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

25

Rex
Binary Crashing
Input

Symbolic Tracing and
Crash Triaging

Techniques
ROP Shellcode Circumstance
Explore ...

Generate exploit C code

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

26

Rex ­ Crash Triaging

Instruction pointer overwrite
Arbitrary write

Is instruction pointer
symbolic?
Is the target address symbolic?

Last BB contain a
write?

Last BB contain a
read?

Arbitrary read

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

27

Rex ­ Symbolic Tracing
 Understand "how" to control the crash

v1 = user_input1() v2 = user_input2()
if(v1 > 10){ if (v1 == 3){ foo() }else if(v1 == 7){ bar()
} }else{
if((v1^2 - 19087925*v1)==57263784){ function_pointer = v2 + 300 function_pointer()
} }

If this instruction is reached the program crashes

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

28

Rex ­ Symbolic Tracing
 Understand "how" to control the crash

v1 = user_input1() v2 = user_input2()
if(v1 > 10){ if (v1 == 3){ foo() }else if(v1 == 7){ bar()
} }else{
if((v1^2 - 19087925*v1)==57263784){ function_pointer = v2 + 300 function_pointer()
} }

Using symbolic tracing, we know:
instruction_pointer = function_pointer = v2 + 300 = user_input2 + 300

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

29

Rex ­ Symbolic Tracing
 Understand "how" to control the crash

v1 = user_input1() v2 = user_input2()
if(v1 > 10){ if (v1 == 3){ foo() }else if(v1 == 7){ bar()
} }else{
if((v1^2 - 19087925*v1)==57263784){ function_pointer = v2 + 300 function_pointer()
} }

Using symbolic tracing, we know:
instruction_pointer = user_input2 + 300
Therefore:
- By controlling the user input we control the instruction pointer

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

30

Rex ­ Symbolic Tracing
 Understand "how" to control the crash

v1 = user_input1() v2 = user_input2()
if(v1 > 10){ if (v1 == 3){ foo() }else if(v1 == 7){ bar()
} }else{
if((v1^2 - 19087925*v1)==57263784){ function_pointer = v2 + 300 function_pointer()
} }

Using symbolic tracing, we know:
instruction_pointer = user_input2 + 300
Therefore:
- By controlling the user input we control the instruction pointer
- If we want: instruction_pointer = X
we have to set: user_input2 = X - 300

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

31

Rex ­ Techniques
 Crashing input  Exploit

Instruction pointer control

Arbitrary Write

Jump to Shellcode Pivot to ROP chain "Circumstantial"

Point-to-Data Explore for Exploit

Arbitrary Read Point-to-Flag Point-to-Data

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

32

Rex ­ Technique: Jump to Shellcode
 We want to place shellcode in buffer and jump to it
v1 = user_input1() buffer = base64_decode(user_input2()) //... function_pointer = v1 + 300 function_pointer()

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

33

Rex ­ Technique: Jump to Shellcode
 We want to place shellcode in buffer and jump to it

v1 = user_input1() buffer = base64_decode(user_input2())
//...
function_pointer = v1 + 300 function_pointer()

Using symbolic tracing, we know:
instruction_pointer = user_input1 + 300 buffer = base64_decode(user_input2)

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

34

Rex ­ Technique: Jump to Shellcode
 We want to place shellcode in buffer and jump to it

v1 = user_input1() buffer = base64_decode(user_input2())
//...
function_pointer = v1 + 300 function_pointer()

Using symbolic tracing, we know:
instruction_pointer = user_input1 + 300 buffer = base64_decode(user_input2)
We want:
instruction_pointer = &(buffer) buffer = shellcode

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

35

Rex ­ Technique: Jump to Shellcode
 We want to place shellcode in buffer and jump to it

v1 = user_input1() buffer = base64_decode(user_input2())
//...
function_pointer = v1 + 300 function_pointer()

Using symbolic tracing, we know:
instruction_pointer = user_input1 + 300 buffer = base64_decode(user_input2)
We want:
instruction_pointer = &(buffer) buffer = shellcode
Therefore:
user_input1 = &(buffer) - 300 user_input2 = base64_encode(shellcode)

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

36

Colorguard
 Memory-leak (Type 2) exploits  Use symbolic tracing  Analyze all inputs

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

37

Colorguard
 Memory-leak (Type 2) exploits are also generated using symbolic tracing

v1 = user_input1()
//...
printed_value = array[v1] print(printed_value)

Using symbolic tracing, we know:
printed_value = *(&array + v1) v1 = user_input1
We want:
printed_value = flag_page[0]
Therefore:
user_input1 = (&flag_page) - (&array)

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

38

Colorguard ­ Unicorn Engine
 Every testcase can potentially leak the flag page
 Full symbolic tracing of every testcase is too slow
 angr + unicorn engine (QEMU wrapper)  Execute "most" of the code in QEMU

angr

unicorn engine

QEMU

3,000,000 times slower than a real CPU

2~5 times slower than a real CPU

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

39

How to play?
Automatic Binary Patching

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

40

Automatic Patching

 Prevent binary form being exploit

 Preserve binary functionality

 Preserve binary performance  speed  memory usage  disk space

 Prevent analysis from other teams

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

41

Patcherex
Patching Techniques
Patches

Original Binary

Patching Backends

Patched Binary

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

42

Patcherex
 Defensive Techniques  Return pointer encryption  Protect indirect calls/jmps  Extended Malloc allocations  Randomly shift the stack (ASLR)  ...

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

43

Patcherex
 Adversarial Techniques
 Detect QEMU
mov eax, 0x1 push eax push eax push eax fld TBYTE PTR [esp] fsqrt
 Backdoor
 ...

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

44

Patcherex
 Making the original binary faster  Our patches can be slower!

 Optimization Techniques:  Constant Propagation

 Dead Assignment Elimination

 ...

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

45

Patcherex ­ Backends
 Patching Backends  Inject code/data in an existing binary  No source code  No symbols

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

46

Patcherex ­ Backends
 How to inject code without breaking functionality?

0x0 : mov eax, 0x11 0x5 : jmp eax 0x7 : mov edx, 0x11223344 0xc : mov ebx, 0x55667788 0x11: mov ecx, ebx

0x0 : mov eax, 0x11 0x5 : jmp eax 0x7: call inserted_function 0xc : mov edx, 0x11223344 0x11: mov ebx, 0x55667788 0x16: mov ecx, ebx

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

47

Patcherex ­ Backends

 Detour Backend  Try to add code without moving the original one  Not always possible  Slow (requires a lot of additional jmp instructions)

0x0 : mov eax, 0x11 0x5 : jmp eax 0x7 : mov edx, 0x11223344 0xc : mov ebx, 0x55667788 0x11: mov ecx, ebx

0x0 : mov eax, 0x11 0x5 : jmp eax 0x7 : jmp out1 0xc : mov ebx, 0x55667788 0x11: mov ecx, ebx

mov edx, 0x11223344 call inserted_function jmp 0xc

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

48

Patcherex ­ Backends
 Reassemler Backend  Recover original "program symbols"  More efficient code  (Slightly) less reliable

Ramblr: Making Reassembly Great Again. R. Wang, Y. Shoshitaishvili, A. Bianchi, A. Machiry, J. Grosen, P. Grosen, C. Kruegel, G. Vigna In NDSS 2017

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

49

Patcherex ­ Backends

0x0 : mov eax, 0x11

mov eax, _label1

mov eax, _label1

0x5 : jmp eax

jmp eax

jmp eax

0x7 : mov edx, 0x11223344

mov edx, 0x11223344

call inserted_function

0xc : mov ebx, 0x55667788

mov ebx, 0x55667788

mov edx, 0x11223344

0x11: mov ecx, ebx

_label1:

mov ebx, 0x55667788

mov ecx, ebx

_label1:

0x0 : mov eax, 0x16

mov ecx, ebx

0x5 : jmp eax

0x7 : call inserted _function

0xc : mov edx, 0x11223344

0x11: mov ebx, 0x55667788

0x16: mov ecx, ebx

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

50

How to play?
Infrastructure

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

51

Infrastructure
 Our code had to run for 10 hours on: 64 servers, 16TB of RAM, 2560 cores
 No human intervention  No possibility of failure!
 Extremely hard to test the full system  A lot of test cases  Testing after every single git push

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

52

Infrastructure
 Separate and (mostly) independent tasks
 Every task run in a separate container  Docker
 Tasks are distributed "transparently" among servers  Kubernetes

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

53

What Happened?

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

54

Results
 Exploitation  2442 Exploits generated
 1709 Exploits for 14/82 challenges with 100% Reliability

 Longest exploit: 3791 lines of C code  crackaddr: 517 lines of C code

 Shellphish exploited the most binaries!

 Defense

 Only 12/82 services were compromised

 Second best team in terms of defense points

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

55

Third Place! ::\OwO/::
 Third Place!
 Happiness!
 First among University-only teams  First among unfunded teams

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

56

Results

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

57

$$$
750,000 $ + 750,000 $ = 1,500,000 $

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

58

What went wrong
 Our strategy was not ideal ~~   Patch everything!  Score penalty  Only 20/82 binaries were exploited in total

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

59

Open source release
 Open source all the code!

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

60

Open source release
 About 100,000 lines of Python code  github.com/shellphish
 Core, independent components: REX, Patcherex, ...  github.com/mechaphish
 Infrastructure, utilities, and documentation  github.com/angr
 Binary analysis framework, symbolic execution, ...

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

61

Standing on the shoulders of giants

AFL

Unicorn Engine

VEX

Capstone Engine

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

62

Future Directions
 Human-assisted automatic exploitation and defense

 You can contribute

 Port code to non-CGC architecture

 Are you a student?

Looking for an internship? Master thesis?

Wanting to do a PhD?

Want a free Shellphish Tshirt/sticker?

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

63

CGC ­ Timeline

QuOanlliifnieceavteinotn, J!une 2015

FinLaivlese!vent, August 2016

2014
Shellphish signs up!

Two crazy months! Open source release!

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

65

The END

Questions?

References: - all the technical details: "very soon" published in a "popular security ezine" - this presentation: goo.gl/RvDbxS - CGC final event show: youtu.be/n0kn4mDXY6I - Twitter:@shellphish - Twitter team: @anton00b - @caovc - @giovanni_vigna - @jac_arc - @ltFish_ @machiry_msdic - @nebirhos - @rhelmot - @zardus - email: antoniob@cs.ucsb.edu - team@shellphish.net - Github: github.com/shellphish - github.com/mechaphish - github.com/angr

Automatic Binary Exploitation and Patching using Mechanical [Shell]Phish

73

