This is DEEPerent: Tracking App behaviors with (Nothing changed) phone for Evasive android malware

What I will talk about..
· Challenges we faced on android malware analysis:
­ Fast code analysis (Reversing) <- always challenge  ­ Obfuscation ­ Various dynamic code loading techniques (file/memory) ­ Anti-analysis techniques(advanced android malware,
protectors) ­ Native behavior, obfuscation, packing ­ Maintenance ­ Environment detection (Emulator/Rooting detection)

What I will talk about..
· A tool for tracking execution flow of android malware
­ Supports tracking the android application with your nothing changed phone
­ The tool has following features to track behaviors of evasive android malwares:
· No platform modification · Regardless of root privilege · Selective behavior tracking · Support tracking extension(plug-in) · Native layer monitoring (libc, JNI, Binder)

What I will talk about..
· Flow-centric code analysis
­ DEX exports a lot of code informations such as method arguments, debug symbols, register information, etc.
­ DVM supports JDWP(Java Debug Wired Protocol) ­ JDWP is excellent tracer for monitoring app's behaviors 
· Method execution flow · Symbol information · Object tracking · Call stack · Etc..
­ ART(Android Runtime) supports JDWP

Fast code analysis
· Tracking behaviors of evasive android malware
­ User-defined method and Third-party libraries monitoring (Crypto, Network, etc)
­ Obfuscated code monitoring (String, Reflection, AssetEncryption, etc)
­ Dynamic loaded code detecting and tracing ­ Breaking anti-analysis techniques
(anti-jdwp, anti-gdb, anti-emulator, device detection, etc)

Fast code analysis
· Tracking behaviors of evasive android malware
­ This code steals phone number, mac address, ip address, IMEI and IMSI

Obfuscation
· Symbol name obfuscation

Obfuscation
· String encryption
­ String obfuscation of DexGuard Disassembled code of string obfuscation
Discompiled code of string obfuscation

Obfuscation
· String encryption
Code position (for static analysis)
Method tracing of String object
Decrypted string
deobfuscated string is "Hello world!"

Obfuscation
· Method invocation hiding
­ Method invocation hiding of DexGuard ­ Method invocation hiding insist of string encryption and Java
reflection

Obfuscation
· Method invocation hiding
­ Method invocation hiding of DexGuard (Most invocation hiding is performed using Java reflection)
java.lang.reflect.Method->invoke (Method hiding by java reflection)
A object of dalvik.system.DexFile created using java reflection

Fast code analysis: example
· Complicated code: TamperDetection of DexGuard
­ DexGuard employs multiple obfuscation techniques (String encryption, Class encryption, method invocation hiding)

Fast code analysis: example
· Complicated code: TamperDetection of DexGuard
1st loading
2nd loading
Integrity checking routine

Fast code analysis: example
· Complicated code: TamperDetection of DexGuard
Certification checking routine

Dynamic code loading
· Dynamic loading: DEX file
­ There are several hooking point to detect dynamic code loading ­ You can get the loaded dex file with collaboration between
JDWP and Injected code
Injected Code

Alarm! and Extraction!

Second DEX file

Detect dynamic loading!
App DEX
<App process>

Dynamic code loading

· Dynamic loading: memory patch

­ To patch code, it needs to call mprotect() to change memory privilege writable to patch code

­ We hook the mprotect() and rejects request for write privilege

­ It will cause access violation (SIGSEGV)
Signal handler

DEX image (read-only area)

Alarm! and Extraction!

- Instruction caused the signal

(Code address in CodePatch.so)

- Accessed memory address

(Encrypted area)

- Thread context

Write!

Code area

CodePatch.so

<App process>

We found Unpacking routine of APKProtect easily! without reversing 

In sigHandler function, we got these information 1) Address of instruction caused segmentation fault: 0x40147370
- Link Register: 0x727ee4a1 2) Accessed memory address: 0x727e203c 3) Thread context (PC: 0x40147370)
- Address 0x40147370 is in memset function - 0x727ee4a1 is for apkprotect.so - While loop is unpacking routine - Scalpel detected the unpacking point

Accessed memory: 0x727e203c is in classes.dex
- 727df000-727e3000 rw-p 00000000 b3:1a 918654 /data/dalvik-cache/data@app@google.service-1.apk@classes.dex - 727e3000-727e4000 r--p 00004000 b3:1a 918654 /data/dalvik-cache/data@app@google.service-1.apk@classes.dex - 727e4000-727ed000 rw-p 00005000 b3:1a 918654 /data/dalvik-cache/data@app@google.service-1.apk@classes.dex - 727ed000-727f1000 r-xp 00000000 b3:1a 1179701 /data/app-lib/google.service-1/libAPKProtect.so Link Register: - 727f1000-727f2000 -w-p 00003000 b3:1a 1179701 /data/app-lib/google.service-1/libAPKProtect.so x727e203c - 727f2000-727f3000 rw-p 00004000 b3:1a 1179701 /data/app-lib/google.service-1/libAPKProtect.so

Monitoring extension
· Monitoring extension performs using dex injection · We can inject monitoring extension whenever it needs · We makes our own process environment to track behaviors of the
evasive android application using wait-for-debug feature
(Wait-for-debug feature has presented in BlackHat ASIA 2015 )
· With monitoring extension, we can get the various things in nothing changed phone such as anti-analysis techniques, file extraction, Exploring app private directory, various detection, etc

Mixed-environment code with JNI

· Malwares conceal their behaviors with using Native code

Java

Export table

Native code

 
?

Encrypted string

Example(Fake KakaoTalk Security Plug-in) www.virusbtn.com/virusbulletin/archive/2013/12/vb201312-KakaoTalk

Tracking Native Behavior
· Need 3-layer monitoring
­ JNI : calling native, calling Java ­ Libc : calling libc ­ Binder : communication with other app/service

Tracking Native Behavior
Java Component
Dalvik VM

Native Tracker

Native Component

Libc Target App

Android App, Service Manager

Binder

Tracking Native Behavior : JNI
· Java  Native
­ Hook dvmCallJNIMethod()
void dvmCallJNIMethod(unsigned int const* args, Jvalue *pResult, Method const* method, void *self)
· Native  Java
­ Change functions table in JNIEnv
jint JNI_xxxxxxx(JNIEnv* env, void *reserved )

Tracking Native Behavior : JNI

Tracking Native Behavior : LIBC
· Monitor calling libc with JNI
Showing libc function and call stack

Tracking Native Behavior : BINDER
· NOT hooking ioctl() at binder driver · Hooking Binder function(related transact) at IPC
layer
­ So we can monitor custom service ­ No performance issue
· Can see all Message between targeted App and service/app through the binder

Tracking Native Behavior : BINDER

Service Client

Service Server

Service User

Service Layer

BnFooService
foo()

BpFooService
foo()
BpBinder
transact()
IPCThreadState
transact()
talkWithDriver()
Ioctl()

RPC Layer IPC Layer

BnFooService
onTransact()
BBinder
onTransact() transact()
IPCThreadState
executeCommand() talkWithDriver()
Ioctl()

Service Layer

Binder Driver

Tracking Native Behavior : BINDER
Target Service Service Code
Service Data dump Reply Data dump

Tracking Native Behavior : BINDER
· In addition to protecting information of analyst
­ Camera, MIC, GPS ­ Device info(phone number, IMEI, USIM, IMSI, etc)

DEMO

Thank you
Yeongung Park: santapark5@gmail.com Junyoung Choi: iamyoung00@gmail.com

