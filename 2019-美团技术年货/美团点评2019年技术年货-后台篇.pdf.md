


 Java Unsafe  Java   JVM CPU Profiler  Java   ReentrantLock  AQS 
  Kubernetes   HULK   IDC  HIDS  Leaf ID   OCTO   OCTO2.0 
 XGBoost  Spring Boot "" 

1
2 2 19 31 58 81 110
146 146 161 174 197 204 210
226 226 235 247

iv> 2019 



258



276



291


 
2019  18   3 Java   Kubernetes   HULK  
   
 18  

2> 2019 



Java Unsafe 



Unsafe  sun.misc   Java  Java  Unsafe  Java  C   Unsafe   Java "" Unsafe 
 sun.misc.Unsafe  API 

 Unsafe Unsafe  getUnsafe  Unsafe  getUnsafe   SecurityException 
public final class Unsafe { //  private static final Unsafe theUnsafe;
private Unsafe() { } @CallerSensitive public static Unsafe getUnsafe() {
Class var0 = Reflection.getCallerClass();

<3
//  `BootstrapClassLoader`  if(!VM.isSystemDomainLoader(var0.getClassLoader())) {
throw new SecurityException("Unsafe"); } else {
return theUnsafe; } } }
    getUnsafe              Java      -Xbootclasspath/a  Unsafe  A  jar   bootstrap  A  Unsafe.getUnsafe  Unsafe 
java -Xbootclasspath/a: ${path} //  path  Unsafe  jar 
 theUnsafe
private static Unsafe reflectGetUnsafe() { try { Field field = Unsafe.class.getDeclaredField("theUnsafe"); field.setAccessible(true); return (Unsafe) field.get(null); } catch (Exception e) { log.error(e.getMessage(), e); return null; }
}

4> 2019 

Unsafe  API CASClass   


//  ,  C++  malloc  public native long allocateMemory(long bytes); //  public native long reallocateMemory(long address, long bytes); //  public native void freeMemory(long address); //  public native void setMemory(Object o, long offset, long bytes, byte value); //  public native void copyMemory(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes); //  : getIntgetDouble getLonggetChar  public native Object getObject(Object o, long offset); //  : putInt,putDouble putLongputChar  public native void putObject(Object o, long offset, Object x);

<5
//  byte  allocateMemory    public native byte getByte(long address); //  byte  allocateMemory    public native void putByte(long address, byte x);
 Java heap JVM  Java  JVM JVM   JVM  Java  Unsafe  native 

  JVM  GC  
  I/O  I/O   

DirectByteBuffer  Java   NettyMINA  NIO DirectByteBuffer   Unsafe  API 
   DirectByteBuffer       DirectByteBuffer      Unsafe.allocateMemory Unsafe.setMemory   Cleaner  DirectByteBuffer  DirectByteBuffer 

6> 2019 
 Cleaner  Cleaner    Java             PhantomReference   GC  PhantomReference  ReferenceQueue   Cleaner  JVM  pending  Reference-Handler Reference-Handler   pending  Cleaner  clean 

<7

 DirectByteBuffer  Cleaner  GC  DirectByteBuffer  Reference-Handler  Cleaner  clean  Cleaner  Deallocator 

CAS 
 CAS 

/** * CAS
* @param o

 field 

8> 2019 

* @param offset  field  * @param expected 

* @param update 

* @return

true | false

*/

public final native boolean compareAndSwapObject(Object o, long

offset, Object expected,

Object update);

public final native boolean compareAndSwapInt(Object o, long offset, int expected,int update);

public final native boolean compareAndSwapLong(Object o, long offset, long expected, long update);

 CAS? CAS  ---- CAS                                   CAS  CPU  cmpxchg Unsafe  CAS  compareAndSwapXXX CPU  cmpxchg

CAS  java.util.concurrent.atomic Java AQSCurrentHashMap       AtomicInteger  valueOffset  value valueOffset  AtomicInteger              Unsafe  objectFieldOffset      AtomicInteger  valueOffset  AtomicInteger  value  CAS  value  

<9
 AtomicInteger  baseAddress="0x110000"   baseAddress+valueOffset   value    valueAddress="0x11000c" CAS  



10> 2019 
//  public native void unpark(Object thread); //  public native void park(boolean isAbsolute, long time); //  @Deprecated public native void monitorEnter(Object o); //  @Deprecated public native void monitorExit(Object o); //  @Deprecated public native boolean tryMonitorEnter(Object o);
 parkunpark 
 park  park 
unpark 

Java  AbstractQueuedSynchronizer
 LockSupport.park()  LockSupport.unpark()            
LockSupport  parkunpark  Unsafe  parkunpark 

Class 
 Class 
 & 
//  public native long staticFieldOffset(Field f); //  public native Object staticFieldBase(Field f); //     ensureClassInitialized   false public native boolean shouldBeInitialized(Class<?> c); //  

<11
public native void ensureClassInitialized(Class<?> c); //  JVM ClassLoader  ProtectionDomain public native Class<?> defineClass(String name, byte[] b, int off, int len, ClassLoader loader, ProtectionDomain protectionDomain); //  public native Class<?> defineAnonymousClass(Class<?> hostClass, byte[] data, Object[] cpPatches);

 Java 8 JDK  invokedynamic  VM Anonymous Class   Java  Lambda 
 invokedynamicinvokedynamic  Java 7  JVM   invokedynamic  
 VM Anonymous Class   Unsafe.defineAnonymousClass   ClassLoader   Class   GC  VM Anonymous Class  Java   ClassClassLoader 
 Lambda  invokedynamic   ASM  Unsafe  defineAnonymousClass    Lambda  Test

12> 2019  
Test  class   main invokedynamic          BootstrapMethods      lambda$main$0   Lambda  Unsafe. defineAnonymousClass  Consumer  accept  Test  lambda$main$0  Lambda  consumer.accept"lambda"  accept 

<13


//  public native long objectFieldOffset(Field f); // getIntgetDoublegetLong getChar  public native Object getObject(Object o, long offset); // putIntputDoubleputLong putChar  public native void putObject(Object o, long offset, Object x); //  volatile  public native Object getObjectVolatile(Object o, long offset); //  volatile  public native void putObjectVolatile(Object o, long offset, Object x); //  putObjectVolatile   field  volatile  public native void putOrderedObject(Object o, long offset, Object x); //  public native Object allocateInstance(Class<?> cls) throws InstantiationException;

   new new 


            Unsafe    allocateInstance     
Class 
JVM  private 

allocateInstance  java.lang.invokeObjenesis
Gson
 Gson 

14> 2019                 UnsafeAllocator           UnsafeAllocator  Unsafe  allocateInstance  

 arrayBaseOffset  arrayIndexScale  
//  public native int arrayBaseOffset(Class<?> arrayClass); //  public native int arrayIndexScale(Class<?> arrayClass);

 java.util.concurrent.atomic  AtomicIntegerArray Integer   AtomicIntegerArray  Unsafe  arrayBaseOffset arrayIndexScale  base  scale  getAndAdd  checkedByteOffset   CAS 

<15

 Java 8   CPU   
//  load  load  load  public native void loadFence(); //  store  store   store  public native void storeFence(); //  loadstore  public native void fullFence();

 Java 8 ----StampedLock StampedLock  ""  StampedLock   load  StampedLock  

16> 2019 
 Point  move   distanceFromOrigin distanceFromOrigin   tryOptimisticRead  (x,y)  StampedLock  validate  (x,y)   move  validate  true (x, y)   (x,y)   copy  
 StampedLock.validate   Unsafe  loadFence   load  StampedLock.validate  

<17


//  432  864  public native int addressSize(); //  2  public native int pageSize();

 java.nio  Bits   Unsafe  pageSize  

18> 2019 

 Java  sun.misc.Unsafe   Unsafe  API  Unsafe   

 OpenJDK Unsafe source  Java Magic. Part 4: sun.misc.Unsafe  JVM crashes at libjvm.so  Java  ­Unsafe  JVM     DirectByteBuffer    Java  2 

 Java 2017  

Java 


<19


 
"Debug " " Debug " "" "" "" "" " Review  " " " "" " Review "
 JSP 
 Java  JSPJava Server Pages  
 Java  JSP  

20> 2019  "" " for " "                         
Sesstion " "" ...... 
  JVMJava   JSP  Java   class   JSP  JSP 
 JSP  :
JSP 
JSP  Web Tomcat  JSP  JSP 

<21
 Sevlet  JVM  Servet   Java  ClassLoader  Web  ClassLoader   Servlet  Servlet   JSP 
HTTP  JSP   ClassLoader ""class  Spring   ClassLoader 

Java 
 JSP    JVM 

public class Person{ private int age; private String name; public void speak(String str) { System.out.println(str);
} public Person(int age, String name) {
this.age = age; this.name = name; } }

22> 2019 
 Person  age  name speak    Person personA  personB
Person personA = new Person(43, "lixunhuan"); personA.speak("  "); Person personB = new Person(23, "afei"); personB.speak("  ");
personA  personB speak  Java 
" "
"" ""  
Method area is created on virtual machine startup, shared among all Java virtual machine threads and it is logically part of heap area. It stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors. Java  "" " class " "class " " Java  JVM " "" ""

<23
"......    JVM  ClassLoader"
" java.lang.instrument.Instrumentation"
java.lang.instrument.Instrumentation
redefineClasses  retransformClasses class class reDefineClasses 
This method is used to replace the definition of a class without reference to the existing class file bytes, as one might do when recompiling from source for fix-and-continue debugging. Where the existing class file bytes are to be transformed (for example in bytecode instrumentation) retransformClasses should be used.  class redefineClasses   class retransformClasses    class   field  instrument  The redefinition may change method bodies, the constant pool and attributes. The redefinition must not add, remove or rename fields or methods, change the signatures of methods, or change inheritance. These restrictions maybe be lifted in future versions. The class file bytes are not checked, verified and installed until after the transforma-

24> 2019 
tions have been applied, if the resultant bytes are in error this method will throw an exception.   reTransform    class  Java  class  redefineClasses   JVM   Java Scala  JVM   class JVM  class  "JVM "  class 

Java             class     JVM       class  JVM    Java   
 Java     ASM cglibSpring   ASM 
Spring  AOP Spring  

<25
Spring  Spring   Java  class Spring "" class  class  ASM 
 ASM  class   retransformClasses 
BTrace
 
1.  reTransform   
2.  JVM  3.  ASM ""
 BTrace  BTrace  BTrace 
A safe, dynamic tracing tool for the Java platform. BTrace  Java BTrace  ASMJava Attach ApiInstruments   BTrace  Java   ASM   BTrace  java.io  read   IO 

26> 2019 

package com.sun.btrace.samples;
import com.sun.btrace.annotations.*; import com.sun.btrace.AnyType; import static com.sun.btrace.BTraceUtils.*;
/** * This sample demonstrates regular expression * probe matching and getting input arguments * as an array - so that any overload variant * can be traced in "one place". This example * traces any "readXX" method on any class in * java.io package. Probed class, method and arg * array is printed in the action. */
@BTrace public class ArgArray { @OnMethod( clazz="/java\\.io\\..*/", method="/read.*/" ) public static void anyRead(@ProbeClassName String pcn, @
ProbeMethodName String pmn, AnyType[] args) {
println(pcn); println(pmn); printArray(args); } }
 2 
package com.sun.btrace.samples;
import com.sun.btrace.annotations.*; import static com.sun.btrace.BTraceUtils.*; import com.sun.btrace.annotations.Export;
/** * This sample creates a jvmstat counter and * increments it everytime Thread.start() is * called. This thread count may be accessed * from outside the process. The @Export annotated * fields are mapped to jvmstat counters. The counter * name is "btrace." + <className> + "." + <fieldName> */

<27
@BTrace public class ThreadCounter {
// create a jvmstat counter using @Export @Export private static long count;
@OnMethod( clazz="java.lang.Thread", method="start"
) public static void onnewThread(@Self Thread t) {
// updating counter is easy. Just assign to // the static field! count++; }
@OnTimer(2000) public static void ontimer() {
// we can access counter as "count" as well // as from jvmstat counter directly. println(count); // or equivalently ... println(Counters.perfLong("btrace.com.sun.btrace.samples. ThreadCounter.count")); } }
 HashMap  rehash
 BTrace BTrace   Git  BTrace  BTrace 
 
 BTrace  BTrace  
BTrace 
1. BTrace  BTrace  

28> 2019  2. Compiler BTrace  BTrace class  3. Client class  Agent 4. Agent Java  Attach ApiAgent  JVM  BTrace Server client  BTrace   Java Instrument  reTransform   BTrace 
BTrace 
BTrace  Instruments  class  Instruments BTrace BTrace  JVM  "" BTrace 

<29
1.  2.  3.  4.  catch  5.                       com.sun.btrace.
BTraceUtils  6.  7.  static public void  8.  9.  10.  11. java.lang.Object  12.  13.  assert 14.  Class 
BTrace  
Arthas
BTrace   2018  9  Java ---- ArthasArthas  Arthas 
 Java  ""

30> 2019 

"" Java  Instruments Attach API  ""ASM "" Java   Instruments  Attach API  JProfilerJvisualvm BTraceArthas  ASM  cglib  Spring AOP Java Java 5  InstrumentsJava 6  Attach API  ""     0  1   "" 

2017 




<31

1. 
1.1
Java "" JVM   .class  JVM  Java   JVM   Java  javac   .java  1 

 1Java 
 Java   Volatile   Spring AOP ORM   JVM 

32> 2019   JVM  JVM  ScalaGroovyKotlin Java  "" ""
 JVM   Java  
1.2
.java     javac         .class            ByteCodeDemo  2 
 2
 ByteCodeDemo.class   2 JVM   JVM   3  

<33
 3JVM 
1Magic Number  .class 0xCAFEBABE        JVM                        .class   Java  James Gosling  CafeBabe  Java  2  4 Minor Version Major Version 2 "00 00 00 34"  0 52 Oracle  52  1.8 Java  1.8.0 3Constant Pool   Final    4 

34> 2019 
 4
 constant_pool_count  2  10   5  24  36"0"  35 
 5
 constant_pool_count-1 cp_info   cp_info  14  cp_info  6 

<35
 6 cp_info
 CONSTANT_utf8_info  7  "tag" 6  Tag utf8_info "01" Length Length   2  cp_info  7   utf8 "a"

36> 2019 
 7CONSTANT_utf8_info 
 cp_info  Tag   n  javap-verbose ByteCodeDemo  JVM  8  cp_info 
 8

<37 4  Class  Public AbstractFinal JVM  9 Access_ FlagJVM   Public Final ACC_ PUBLIC | ACC_FINAL 0x0001 | 0x0010=0x0011
 9
5   6  

38> 2019  7 
 n  8 
  fields_info
 10
 2  11  9 0002  Private 8 "a" "I" int private int a
 11
9   

<39
 12
 9  ""  javap -verbose  13 
 13

40> 2019 
"  Code " JVM  "Code "
"  LineNumberTable" Code  Debug  JVM 
"  LocalVariableTable" This   This JVM  This   Static 
10 
1.3
 13 Code  0  17 .java   JVM    Oracle   iconst_2 2  0x05 int  2   0~17  add() 
1.4
JVM    FILO   CPU  
 JVM    add()  GIF 14   iconst_2  ireturn  13  Code 

0~17 

<41

 14
1.5
 javap   Idea jclasslib 15 "View" "Show Bytecode With jclasslib" 

 15jclasslib 

42> 2019 
2. 
  
 16
2.1ASM
 ASM .class   JVM  17 ASM   AOPCglib  ASM jar   ASM  API ASM  AOP ASM    JVM 

<43
 17ASM 
2.1.1ASM API 2.1.1.1 API ASM Core API  XML  SAX    Core API Core API   ClassReader .class   ClassWriter
   Visitor CoreAPI 
 Visitor MethodVisitor FieldVisitor AnnotationVisitor   AOP MethodVisitor 2.1.1.2 API ASM Tree API  XML  DOM 

44> 2019 
TreeApi  CoreAPI TreeAPI  Node  DOM  
2.1.2 ASM  AOP  ASM  CoreAPI  AOP    Base  process() "process" "start""end"
public class Base { public void process(){ System.out.println("process"); }
}
    ASM   AOP           MyClassVisitor         visit         Generator         ClassReader  ClassWriterclassReader   MyClassVisitor  ClassWriter  Generator  MyClassVisitor 
import org.objectweb.asm.ClassReader; import org.objectweb.asm.ClassVisitor; import org.objectweb.asm.ClassWriter;
public class Generator { public static void main(String[] args) throws Exception { //  ClassReader classReader = new ClassReader("meituan/bytecode/asm/
Base"); ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_
MAXS); //  ClassVisitor classVisitor = new MyClassVisitor(classWriter); classReader.accept(classVisitor, ClassReader.SKIP_DEBUG);

<45
byte[] data = classWriter.toByteArray(); //  File f = new File("operation-server/target/classes/meituan/ bytecode/asm/Base.class"); FileOutputStream fout = new FileOutputStream(f); fout.write(data); fout.close(); System.out.println("now generator cc success!!!!!"); } }
MyClassVisitor  ClassVisitor
 MyMethodVisitor MethodVisitor 

import org.objectweb.asm.ClassVisitor; import org.objectweb.asm.MethodVisitor; import org.objectweb.asm.Opcodes;
public class MyClassVisitor extends ClassVisitor implements Opcodes { public MyClassVisitor(ClassVisitor cv) { super(ASM5, cv); } @Override public void visit(int version, int access, String name, String
signature, String superName, String[] interfaces) {
cv.visit(version, access, name, signature, superName, interfaces);
} @Override public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
MethodVisitor mv = cv.visitMethod(access, name, desc, signature, exceptions);
//Base  process  if (!name.equals("<init>") && mv != null) {
mv = new MyMethodVisitor(mv); } return mv; } class MyMethodVisitor extends MethodVisitor implements Opcodes { public MyMethodVisitor(MethodVisitor mv) {
super(Opcodes.ASM5, mv); }

46> 2019 
@Override public void visitCode() {
super.visitCode(); mv.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;"); mv.visitLdcInsn("start"); mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/ String;)V", false); } @Override public void visitInsn(int opcode) { if ((opcode >= Opcodes.IRETURN && opcode <= Opcodes.RETURN)
|| opcode == Opcodes.ATHROW) { //  "end" mv.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;"); mv.visitLdcInsn("end"); mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/ String;)V", false); } mv.visitInsn(opcode); } } }


     MyClassVisitor    visitMethod           
 <init> 
MyMethodVisitor 
  MyMethodVisitor  visitCode  ASM
 Code  visitCode  AOP 

 MyMethodVisitor  ASM 
 MyMethodVisitor  visitInsn 
"return" AOP

<47       MyMethodVisitor            AOP    ASM  methodVisitor  visitXXXXInsn() XXXX   mv.visitLdcInsn("end")   ldc"end""end"  visitor  Generator  main  Base   target  Base.class   18  MyTest new Base() base.process()   AOP 
 18ASM  AOP 
2.1.3ASM   ASM  visitXXXXInsn()   ASM   visitXXXXInsn()    ASM ASM   ASM ByteCode Outline "Show Bytecode Outline""ASMi-

48> 2019  fied" tab 19  ASM   AOP  visitor  visitMethod()  visitInsn() 
 19ASM Bytecode Outline
2.2Javassist
ASM    Javassist
 Javassist   java   ClassPoolCtClassCtMethod

<49
CtField 
 CtClasscompile-time class class   CtClass  
 ClassPool       ClassPool      CtClass    HashTablekey value  CtClass   pool.getCtClass("className")  pool  CtClass
 CtMethodCtField
 Demo  Javassist   Base  process()  "start""end" pool  CtClass  method.insertBefore  insertAfter   Java 
import com.meituan.mtrace.agent.javassist.*;
public class JavassistTest { public static void main(String[] args) throws NotFoundException,
CannotCompileException, IllegalAccessException, InstantiationException, IOException {
ClassPool cp = ClassPool.getDefault(); CtClass cc = cp.get("meituan.bytecode.javassist.Base"); CtMethod m = cc.getDeclaredMethod("process"); m.insertBefore("{ System.out.println(\"start\"); }"); m.insertAfter("{ System.out.println(\"end\"); }"); Class c = cc.toClass(); cc.writeFile("/Users/zen/projects"); Base h = (Base)c.newInstance(); h.process(); } }

50> 2019 
3. 
3.1
  AOP  ASM  AOP  main  MyClassVisitor  class  new  JVM  main  ASM   main  Javassist  Base 
 JVM   Javassist  Demo  main()         Base b=new Base()         JVM   Base  c.toClass()  20   c.toClass()  ClassLoader  native  defineClass() JVM 
 20 load 
  JVM    Base  main  process()  process() "process"
 JVM  process()  "start""end""process"

<51
"start process end" JVM   Java 
import java.lang.management.ManagementFactory;
public class Base { public static void main(String[] args) { String name = ManagementFactory.getRuntimeMXBean().getName(); String s = name.split("@")[0]; //  Pid System.out.println("pid:"+s); while (true) { try { Thread.sleep(5000L); } catch (Exception e) { break; } process(); } }
public static void process() { System.out.println("process");
} }
3.2Instrument
instrument  JVM  Java   JVMTI  Attach API JVMTI   JDK 1.6 instrument  JVM   JDK 1.6 instrument   instrument  ClassFileTransformer  transform()   transform  ASM  Javassist 
 ClassFileTransformer  TestTransformer  Javassist  Base  process() 

52> 2019 
"start""end"
import java.lang.instrument.ClassFileTransformer;
public class TestTransformer implements ClassFileTransformer { @Override public byte[] transform(ClassLoader loader, String className,
Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) {
System.out.println("Transforming " + className); try {
ClassPool cp = ClassPool.getDefault(); CtClass cc = cp.get("meituan.bytecode.jvmti.Base"); CtMethod m = cc.getDeclaredMethod("process"); m.insertBefore("{ System.out.println(\"start\"); }"); m.insertAfter("{ System.out.println(\"end\"); }"); return cc.toBytecode(); } catch (Exception e) { e.printStackTrace(); } return null; } }
 Transformer JVM 
 Agent Agent  Instrument  JVM 
 Agent Agent  Instrumentation JDK
1.6 Instrumentation  InstrumentNative Code
 Instrument Classpath  Instrumentation 
 Transformer
Agent  Attach  JVM  JVM 
import java.lang.instrument.Instrumentation;
public class TestAgent { public static void agentmain(String args, Instrumentation inst) { //  Transformer Javassist  inst.addTransformer(new TestTransformer(), true); try { //  inst.retransformClasses(Base.class); System.out.println("Agent Load Done.");

} catch (Exception e) { System.out.println("agent load failed!");
} } }

<53

3.3JVMTI & Agent & Attach API
 Agent  JPDAJava Platform Debugger Architecture JVM  JPDA   JDPA  DebuggerJDPA  Java  JDK 
JPDA   Java JVMTIJava  JDWP Java JDI

 21JPDA

54> 2019 
 JVMTI  JVM TIJVM TOOL INTERFACEJVM  JVM  JVM  JVMTI JVM   JVM  JVM  GC  VM 
 Agent  JVMTI Agent  Java   java -agentlib  attach APIjar  Attach  id  Java 
Attach API  JVM   JVM  Dump  jstack  jmap   pid  Dump Attach API   Attach API  loadAgent()  Agent jar   Attach  JVM 
  Agent AgentMain  7  TestAgent 
  TestAgent  MANIFEST.MF  jar  MANIFEST.MF  Agent-Class  TestAgent  
 22Manifest.mf

<55
  Attach API jar  Attach  JVM pid  
import com.sun.tools.attach.VirtualMachine; public class Attacher {
public static void main(String[] args) throws AttachNotSupportedException, IOException, AgentLoadException, AgentInitializationException {
//  JVM pid VirtualMachine vm = VirtualMachine.attach("39333"); vm.loadAgent("/Users/zen/operation_server_jar/operationserver.jar"); } }
    MANIFEST.MF     Agent-Class    Attach    JVM  TestAgent  agentmain()   Instrumentation TestTransformer  Base  javassist " JVM  "
 Base  main()  JVM"process" Attacher  main()  JVM  pid  main()  "process""start""end" 
 23

56> 2019 
3.4
 JVM   JVM  
   Mock Mock   bTrace  Instrument
 JVM
4. 
 JVM   JVM  AOP    
5. 
 ASM4-Guide  Oracle:The class File Format  Oracle:The Java Virtual Machine Instruction Set  javassist tutorial  JVM Tool Interface - Version 1.2



" " 12  3 

<57
 280  
 /  tech@meituan.com

58> 2019 
JVM CPU Profiler 

 Profiling   JVM Profiler  CPUMemory ThreadClassesGC  CPU Profiling CPU Profiling " CPU ""  CPU " CPU Profiling   
 JVM  CPU Profiler  
CPU Profiler 
 JVM Profiler  JProfiler  JVM-Profiler Intellij IDEA   Profiler Blog
 IDEA  Java "Preferences -> Build, Execution, Deployment -> Java Profiler""CPU Profiler" "Run with Profiler" CPU Profiling   5min Profiler "Stop Profiling and Show Results"  Profiling 

<59
Intellij IDEA - 
Intellij IDEA - 


60> 2019 
 "" CPU  
"Run with Profiler"Profiler  JVM Agent  JVM Agent 
JVM Agent 
JVM Agent   JVM JVM  Agent   JVM Agent  C/C++/Rust  JVMTI Agent Java  Java Agent
 Java  Agent 
Plain Text -agentlib:<  >[=<  >]  <  >,  -agentlib:jdwp  -agentlib:jdwp=help -agentpath:<  >[=<  >]  -javaagent:<jar  >[=<  >]  Java  ,  java.lang.instrument
JVMTI Agent
JVMTIJVM Tool Interface JVM  C/C++   DebuggerProfilerMonitorThread Analyser   Java 
 JVMTI  Agent 
// $JAVA_HOME/include/jvmti.h
JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *vm, char *options, void *reserved);

<61
 C/C++ Linux  .so  -agentpath  Java JVM   JavaVM  JNI  JVMTI  JVM 
 JVMTI 
Java Agent
 C/C++  JVMTI Agent JVM  JVMTI  Java  Instrument API   Java  Java Agent jar  Agent   GreysArthasJVM-SandboxJVM-Profiler   Java  Java Agent 
 Java Agent  jar  MANIFEST.MF  Premain-Class 
public static void premain(String args, Instrumentation ins) { // implement
}
 jar  Java Agent -javaagent  jar   Java JVM 
 Instrumentation  Retransform Classes   Class  Trace Instrumentation  Class   JMX   Instrument API  JMX  JVMTI 
 Instrument API 

62> 2019 
CPU Profiler 
 Profiler  Agent   CPU Profiler CPU Profiling  
Sampling vs Instrumentation
 JProfiler JProfiler  CPU Profiling   : Sampling  Instrumentation CPU Profiler  
Sampling  StackTrace "" 
1.   Profiler        Agent       JVM      Profiler
2.   Dump
3.  Dump  
Instrumentation  Instrument API Class   
Instrumentation  AOP   
Sampling  "" JVM  Safe Point""

<63
 CPU Time Sampling Profiler  ""  CPU  Sampling Why (Most) Sampling Java Profilers Are Fucking Terrible
"" Sampling  CPU  Instrumentation  I/O   Profiler  Sampling  Sampling  
 Java Agent + JMX 
 Sampling CPU Profiler  Java Agent + JMX   Java Agent  JVM  ScheduledExecutorService JMX  threadMXBean.dumpAllThreads()  StackTrace
Uber  JVM-Profiler 
// com/uber/profiling/profilers/StacktraceCollectorProfiler.java
/* * StacktraceCollectorProfiler  CpuProfiler * jvm-profiler  CpuProfiler  CpuLoad  Profiler */
//  Profiler  ScheduledExecutorService  Profiler  @Override public void profile() {
ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false); // ... for (ThreadInfo threadInfo : threadInfos) {
String threadName = threadInfo.getThreadName(); // ...

64> 2019 
StackTraceElement[] stackTraceElements = threadInfo. getStackTrace();
// ... for (int i = stackTraceElements.length - 1; i >= 0; i--) {
StackTraceElement stackTraceElement = stackTraceElements[i]; // ... } // ... } }
Uber  Interval  100ms CPU Profiler   dumpAllThreads() Interval   CPU Profiling 
JVM-Profiler  ProfilingStackTraceCPUBusy MemoryI/OMethod Profiling  Kafka  Server 
 JVMTI + GetStackTrace 
 Java  Profiler  Java Agent  AppClassLoader JVM  agent.jar   Class JVM-Profiler   Kafka-Clienthttp-ClientJackson  Greys/Arthas/JVM-Sandbox   ClassLoader  
 C/C++  JVMTI  C API  JVM  CPU Profiler JVMTI 
1.  Agent_OnLoad() JNI  JavaVM*  GetEnv()   JVMTI  jvmtiEnv 

<65
// agent.c
JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {
jvmtiEnv *jvmti; (*vm)->GetEnv((void **)&jvmti, JVMTI_VERSION_1_0); // ... return JNI_OK; }
2.  jvmtiEnv  JVMTI 
//  jthread jvmtiError GetAllThreads(jvmtiEnv *env, jint *threads_count_ptr, jthread **threads_ptr);
//  jthread namedaemonpriority... jvmtiError GetThreadInfo(jvmtiEnv *env, jthread thread, jvmtiThreadInfo* info_ptr);
//  jthread  jvmtiError GetStackTrace(jvmtiEnv *env,
jthread thread, jint start_depth, jint max_frame_count, jvmtiFrameInfo *frame_buffer, jint *count_ptr);
 GetAllThreads() ""jthread  jthread  GetThreadInfo()   jthread  GetStackTrace() 
3.  Buffer   JVMTI  CPU Profiler  JVMTI  GetStackTrace()  JMX  ----Safe Point

66> 2019 
SafePoint Bias 
 Sampling  CPU Profiler   Sampling CPU Profiler  
1.  2.  Profiler 
   CPU "SafePoint Bias"
        JMX    JVMTI  Profiler      SafePoint BiasJVMTI  GetStackTrace()   Caller  GetStackTrace()  GetStackTrace()   UNIX  Handler  GetStackTrace()  JMX  SafePoint Bias Safepoints: Meaning, Side Effects and Overheads
 SafePoint Bias  Hack ----AsyncGetCallTrace
 JVMTI + AsyncGetCallTrace 
  UNIX  UNIX  Handler  UNIX   
OracleJDK/OpenJDK ----AsyncGetCallTrace

<67

//  typedef struct {
jint lineno; jmethodID method_id; } AGCT_CallFrame;
//  typedef struct {
JNIEnv *env; jint num_frames; AGCT_CallFrame *frames; } AGCT_CallTrace;
//  ucontext  trace  void AsyncGetCallTrace(AGCT_CallTrace *trace, jint depth, void *ucontext);
 ucontext   Java 
AsyncGetCallTrace "async"  Native GC   Java AGCT_CallTrace  num_frames    -2  GC
 AsyncGetCallTrace  JVMTI  jvmti.h   JVM   Trick Agent  JVM  Agent_ OnLoad  glibc  dlsym()  JVM  "AsyncGetCallTrace" 
 AsyncGetCallTrace  CPU Profiler 

68> 2019 
1.   Agent_OnLoad()      jvmtiEnv  AsyncGetCallTrace 
 AsyncGetCallTrace  :
typedef void (*AsyncGetCallTrace)(AGCT_CallTrace *traces, jint depth, void *ucontext); // ... AsyncGetCallTrace agct_ptr = (AsyncGetCallTrace)dlsym(RTLD_DEFAULT, "AsyncGetCallTrace"); if (agct_ptr == NULL) {
void *libjvm = dlopen("libjvm.so", RTLD_NOW); if (!libjvm) {
//  dlerror()... } agct_ptr = (AsyncGetCallTrace)dlsym(libjvm, "AsyncGetCallTrace"); }
2.  OnLoad               OnClassLoad 
OnClassPrepare    Hook    jmethodID        
AGCT  Traces  OnClassPrepare 
CallBack  Class  Methods JVMTI 
 jmethodID
void JNICALL OnClassLoad(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread, jclass klass) {}
void JNICALL OnClassPrepare(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread, jclass klass) {
jint method_count; jmethodID *methods; jvmti->GetClassMethods(klass, &method_count, &methods); delete [] methods; }
// ...
jvmtiEventCallbacks callbacks = {0}; callbacks.ClassLoad = OnClassLoad; callbacks.ClassPrepare = OnClassPrepare; jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks)); jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, NULL); jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_PREPARE, NULL);

<69
3.  SIGPROF 
//  handler  ucontext  AsyncGetCallTrace  ucontext void signal_handler(int signo, siginfo_t *siginfo, void *ucontext) {
//  AsyncCallTrace  num_frames  }
// ...
//  SIGPROF  handler struct sigaction sa; sigemptyset(&sa.sa_mask); sa.sa_sigaction = signal_handler; sa.sa_flags = SA_RESTART | SA_SIGINFO; sigaction(SIGPROF, &sa, NULL);
//  SIGPROF  // interval  nanoseconds AsyncGetCallTrace   long sec = interval / 1000000000; long usec = (interval % 1000000000) / 1000; struct itimerval tv = {{sec, usec}, {sec, usec}}; setitimer(ITIMER_PROF, &tv, NULL);
4.  Buffer   AsyncGetCallTrace  CPU Profiler  CPU Profiler  Linux  perf_events  Java  Native  Native   Async-Profiler  Honest-Profiler Async-Profiler  IntelliJ IDEA  Java Profiler Async-Profiler  AsyncGetCallTrace The Pros and Cons of AsyncGetCallTrace Profilers

 
 svg 

70> 2019  FlameGraph  Perl   svg  
base_func;func1;func2;func3 10 base_func;funca;funcb 15
 "" 
 flamegraph.pl 
$ flamegraph.pl stacktraces.txt > stacktraces.svg

 flamegraph.pl 

<71
HotSpot  Dynamic Attach 
            CPU Profiler             JProfiler/Arthas   Profling Java  Agent   Dynamic Attach
JDK  1.6  Attach API JVM  Agent  Profiler 
This is a Sun extension that allows a tool to`attach'to another process running Java code and launch a JVM TI agent or a java.lang.instrument agent in that process. Dynamic Attach  HotSpot   JVM  Agent  Dump Dump 
 sun.tools  Attach
Attach  HotSpot  JDK  Java   Java Agent PreMain  Agent   AgentMain  MANIFEST.MF  Agent-Class  Class
public static void agentmain(String args, Instrumentation ins) { // implement
}
 jar -javaagent  Attach   JVM JDK  API  Attach  Java Agent Arthas 
// com/taobao/arthas/core/Arthas.java

72> 2019 
import com.sun.tools.attach.VirtualMachine; import com.sun.tools.attach.VirtualMachineDescriptor;
// ...
private void attachAgent(Configure configure) throws Exception { VirtualMachineDescriptor virtualMachineDescriptor = null;
//  JVM  for (VirtualMachineDescriptor descriptor : VirtualMachine.list()) {
String pid = descriptor.id(); if (pid.equals(Integer.toString(configure.getJavaPid()))) {
virtualMachineDescriptor = descriptor; } } VirtualMachine virtualMachine = null; try { //  JVM  VirtualMachine.attach()  VirtualMachine  if (null == virtualMachineDescriptor) {
virtualMachine = VirtualMachine.attach("" + configure. getJavaPid());
} else { virtualMachine = VirtualMachine.
attach(virtualMachineDescriptor); }
// ...
//  VirtualMachine#loadAgent() arthasAgentPath  jar attach  JVM 
//  attach  agentmain  String  args virtualMachine.loadAgent(arthasAgentPath, configure. getArthasCore() + ";" + configure. toString()); } finally { if (null != virtualMachine) {
//  VirtualMachine#detach()  virtualMachine.detach(); } } }

<73
 HotSpot  Attach
sun.tools  API  Java  Java Agent  JVM  Attach JVMTI  Agent_OnLoad()  Agent_OnAttach()  JVMTI Agent Attach 
// $JAVA_HOME/include/jvmti.h
JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *vm, char *options, void *reserved);
     Async-Profiler   jattach              Attach  JVM jattach  Async-Profiler  Driver
Usage: jattach <pid> <cmd> [args ...]
Args: <pid>  JVM  ID <cmd>  <args> 

$ jattach 1234 load /absolute/path/to/agent/libagent.so true
libagent.so  ID  1234  JVM  Agent_OnAttach  Attach  euid  egid  Attach  JVM  jattach 
 Main  Attach 
// async-profiler/src/jattach/jattach.c
int main(int argc, char** argv) { //  //  euid  egid

74> 2019 
// ...
if (!check_socket(nspid) && !start_attach_mechanism(pid, nspid)) { perror("Could not start attach mechanism"); return 1;
}
int fd = connect_socket(nspid); if (fd == -1) {
perror("Could not connect to socket"); return 1; }
printf("Connected to remote JVM\n"); if (!write_command(fd, argc - 2, argv + 2)) {
perror("Error writing to socket"); close(fd); return 1; } printf("Response code = "); fflush(stdout);
int result = read_response(fd); close(fd); return result; }
             euid  egid   jattach     
check_socket "socket "check_socket 
// async-profiler/src/jattach/jattach.c
// Check if remote JVM has already opened socket for Dynamic Attach static int check_socket(int pid) {
char path[MAX_PATH]; snprintf(path, MAX_PATH, "%s/.java_pid%d", get_temp_directory(), pid); // get_temp_ directory()  Linux  "/tmp" struct stat stats; return stat(path, &stats) == 0 && S_ISSOCK(stats.st_mode); }
UNIX  Socket "UNIX
Socket" S_ISSOCK 

<75
 UNIX Socket"/tmp/.java_pid"  JVM 
 The attach listener thread then communicates with the source JVM in an OS dependent manner: - On Solaris, the Doors IPC mechanism is used. The door is attached to a file in the file system so that clients can access it. - On Linux, a Unix domain socket is used. This socket is bound to a file in the filesystem so that clients can access it. - On Windows, the created thread is given the name of a pipe which is served by the client. The result of the operations are written to this pipe by the target JVM.
 check_socket   JVM  UNIX Socket 
  Main      check_socket               start_attach_mechanism 
// async-profiler/src/jattach/jattach.c
// Force remote JVM to start Attach listener. // HotSpot will start Attach listener in response to SIGQUIT if it sees .attach_pid file static int start_attach_mechanism(int pid, int nspid) {
char path[MAX_PATH]; snprintf(path, MAX_PATH, "/proc/%d/cwd/.attach_pid%d", nspid, nspid);
int fd = creat(path, 0660); if (fd == -1 || (close(fd) == 0 && !check_file_owner(path))) {
// Failed to create attach trigger in current directory. Retry in /tmp
snprintf(path, MAX_PATH, "%s/.attach_pid%d", get_temp_ directory(), nspid);
fd = creat(path, 0660); if (fd == -1) {
return 0; } close(fd);

76> 2019 
}
// We have to still use the host namespace pid here for the kill() call kill(pid, SIGQUIT);
// Start with 20 ms sleep and increment delay each iteration struct timespec ts = {0, 20000000}; int result; do {
nanosleep(&ts, NULL); result = check_socket(nspid); } while (!result && (ts.tv_nsec += 20000000) < 300000000);
unlink(path); return result; }
start_attach_mechanism "/tmp/.attach_pid"  JVM  SIGQUIT  JVM        start_attach_mechanism             20ms  check_socket  300ms   Unlink  .attach_pid 
HotSpot  SIGQUIT         .attach_pid  HotSpot          "/tmp/. java_pid" UNIX Socket Connect 
 Dynamic attach has an attach listener thread in the target JVM. This is a thread that is started when the first attach request occurs. On Linux and Solaris, the client creates a file named .attach_pid(pid) and sends a SIGQUIT to the target JVM process. The existence of this file causes the SIGQUIT handler in HotSpot to start the attach listener thread. On Windows, the client uses the Win32 CreateRemoteThread function to create a new thread in the target process.
 Linux "/tmp/.attach_pid"

<77
 JVM  SIGQUIT HotSpot "/tmp/. java_pid" UNIX Socket Attach   .attach_pid  Attach Listener   JVM  Attach  SIGQUIT   Attach 
 jattach  connect_socket "/tmp/. java_pid"connect_socket 
// async-profiler/src/jattach/jattach.c
// Connect to UNIX domain socket created by JVM for Dynamic Attach static int connect_socket(int pid) {
int fd = socket(PF_UNIX, SOCK_STREAM, 0); if (fd == -1) {
return -1; }
struct sockaddr_un addr; addr.sun_family = AF_UNIX; snprintf(addr.sun_path, sizeof(addr.sun_path), "%s/.java_pid%d", get_temp_directory(), pid);
if (connect(fd, (struct sockaddr*)&addr, sizeof(addr)) == -1) { close(fd); return -1;
} return fd; }
 Socket  Socket   Main  write_command  Socket   read_response  JVM   Socket 
// async-profiler/src/jattach/jattach.c
// Send command with arguments to socket static int write_command(int fd, int argc, char** argv) {
// Protocol version

78> 2019 
if (write(fd, "1", 2) <= 0) { return 0;
}
int i; for (i = 0; i < 4; i++) {
const char* arg = i < argc ? argv[i] : ""; if (write(fd, arg, strlen(arg) + 1) <= 0) {
return 0; } } return 1; }
// Mirror response from remote JVM to stdout static int read_response(int fd) {
char buf[8192]; ssize_t bytes = read(fd, buf, sizeof(buf) - 1); if (bytes <= 0) {
perror("Error reading response"); return 1; }
// First line of response is the command result code buf[bytes] = 0; int result = atoi(buf);
do { fwrite(buf, 1, bytes, stdout); bytes = read(fd, buf, sizeof(buf));
} while (bytes > 0); return result; }
 write_command  JVM  
<PROTOCOL VERSION>\0<COMMAND>\0<ARG1>\0<ARG2>\0<ARG3>\0
 Load  HotSpot 
1\0load\0/absolute/path/to/agent/libagent.so\0true\0\0
 JVM  Attach

<79

Attach 
Load  HotSpot  JVMTI  Agent

static AttachOperationFunctionInfo funcs[] = {

{ "agentProperties", get_agent_properties },

{ "datadump",

data_dump },

{ "dumpheap",

dump_heap },

{ "load",

JvmtiExport::load_agent_library },

{ "properties",

get_system_properties },

{ "threaddump",

thread_dump },

{ "inspectheap",

heap_inspection },

{ "setflag",

set_flag },

{ "printflag",

print_flag },

{ "jcmd",

jcmd },

{ NULL,

NULL }

};

 threaddump  jstack 


 Profiler  Profiler  CPU Profiler  Attach JVMTIInstrumentationJMX  JVM   Memory ProfilerThread ProfilerGC Analyzer  


 JVM Tool Interface  The Pros and Cons of AsyncGetCallTrace Profilers  Why (Most) Sampling Java Profilers Are Fucking Terrible  Safepoints: Meaning, Side Effects and Overheads  Serviceability in HotSpot    IntelliJ IDEA 2018.3 EAP: Git Submodules, JVM Profiler (macOS and Linux) and
more

80> 2019 

 / 

Base    tech@meituan.com

<81
Java 

    Java  Java   Java   Java-debug-tool 
JVMTIJVM Tool Interface Java         Native      JVMTI JVM GC  Agent  JVM  JVM   Agent  JVM   JVM  JVM  Agent   Debug  Java Agent  
2.1Agent 
JVMTI  Native  Java SE 5  Agent   Native  Java SE 5  Java  Instrumentation java.lang.instrument Agent Native  Java Instrumentation  Agent JVMTI   Java Instrumentation  Agent 
2.1.1 Java Instrumentation API
  Agent 

82> 2019 
Java Agent  JVM  JVM   JVM  Agent
[1] public static void premain(String agentArgs, Instrumentation inst); [2] public static void premain(String agentArgs);
JVM  [1] [1] [2] JVM   Agent
[1] public static void agentmain(String agentArgs, Instrumentation inst); [2] public static void agentmain(String agentArgs);
           AgentArgs   "­ javaagent"      inst  Instrumentation  JVM  
  Main-Class Agent        jar   ManiFest     "Premain-Class" "Agent-Class"
Premain-Class: class Agent-Class: class
  JVM  Agent  jar  JVM   JVM  Agent"-javaagent:[=]" "Java -Help" Agent  JVM  com.sun.tools.attach.VirtualMachine  JVM   JVM Agent  JVM  com.sun. tools.attach.VirtualMachine  Agent 

<83
private void attachAgentToTargetJVM() throws Exception { List<VirtualMachineDescriptor> virtualMachineDescriptors =
VirtualMachine.list(); VirtualMachineDescriptor targetVM = null; for (VirtualMachineDescriptor descriptor :
virtualMachineDescriptors) { if (descriptor.id().equals(configure.getPid())) { targetVM = descriptor; break; }
} if (targetVM == null) {
throw new IllegalArgumentException("could not find the target jvm by process id:" + configure.getPid());
} VirtualMachine virtualMachine = null; try {
virtualMachine = VirtualMachine.attach(targetVM); virtualMachine.loadAgent("{agent}", "{params}"); } catch (Exception e) { if (virtualMachine != null) {
virtualMachine.detach(); } } }
 ID  JVM Attach  JVM 
 Agent VirtualMachine  Attach  Agent 
 JVM  Detach  Agent  JVM  Agent 
 JVM 
2.2 Agent
2.2.1
  JVM JVM                 JVM    
     GC              -agentlib-agentpath
-javaagent AgentJVM  Agent
 JVM 

84> 2019 
// -agentlib and -agentpath if (match_option(option, "-agentlib:", &tail) ||
(is_absolute_path = match_option(option, "-agentpath:", &tail))) {
if(tail != NULL) { const char* pos = strchr(tail, '='); size_t len = (pos == NULL) ? strlen(tail) : pos - tail; char* name = strncpy(NEW_C_HEAP_ARRAY(char, len + 1,
mtArguments), tail, len); name[len] = '\0'; char *options = NULL; if(pos != NULL) { options = os::strdup_check_oom(pos + 1, mtArguments); }
#if !INCLUDE_JVMTI if (valid_jdwp_agent(name, is_absolute_path)) { jio_fprintf(defaultStream::error_stream(), "Debugging agents are not supported in this VM\n"); return JNI_ERR; }
#endif // !INCLUDE_JVMTI add_init_agent(name, options, is_absolute_path);
} // -javaagent } else if (match_option(option, "-javaagent:", &tail)) { #if !INCLUDE_JVMTI
jio_fprintf(defaultStream::error_stream(), "Instrumentation agents are not supported in this VM\n");
return JNI_ERR; #else
if (tail != NULL) { size_t length = strlen(tail) + 1; char *options = NEW_C_HEAP_ARRAY(char, length, mtArguments); jio_snprintf(options, length, "%s", tail); add_init_agent("instrument", options, false); // java agents need module java.instrument if (!create_numbered_property("jdk.module.addmods", "java.
instrument", addmods_ count++)) {
return JNI_ENOMEM; } } #endif // !INCLUDE_JVMTI }
          hotspot/src/share/vm/runtime/arguments.cpp  
Arguments::parse_each_vm_init_arg(const JavaVMInitArgs* args, bool* patch_

<85
mod_javabase, Flag::Flags origin)  JVM   Agent  add_init_agent   add_init_agent 
// -agentlib and -agentpath arguments static AgentLibraryList _agentList; static void add_init_agent(const char* name, char* options, bool absolute_path)
{ _agentList.add(new AgentLibrary(name, options, absolute_path, NULL)); }
AgentLibraryList add_init_agent   Agent 
 -javaagent   Java Instrumentation API  AgentJava Instrumentation API  JVMTI -JavaAgent  add_init_ agent "instrument" Agent   JVM  Agent  JVM   JVM  Agent 
2.2.2
 JVM  JVM  Agent 
// Launch -agentlib/-agentpath and converted -Xrun agents if (Arguments::init_agents_at_startup()) {
create_vm_init_agents(); } static bool init_agents_at_startup() {
return !_agentList.is_empty(); }
 JVM  Agent  create_vm_init_agents  Agent create_vm_init_agents  Agent 

86> 2019 
void Threads::create_vm_init_agents() { AgentLibrary* agent; for (agent = Arguments::agents(); agent != NULL; agent = agent->next())
{ OnLoadEntry_t on_load_entry = lookup_agent_on_load(agent); if (on_load_entry != NULL) { // Invoke the Agent_OnLoad function jint err = (*on_load_entry)(&main_vm, agent->options(), NULL); }
} }
create_vm_init_agents  Agent  Agent  lookup_agent_on_load  Agent  Agent_OnLoad  Agent   Agent Agent  Java Instrumentation API  Agent               add_init_agent              "instrument" Linux   libinstrument.so  BSD      libinstrument.dylib        {JAVA_HOME}/jre/lib/ 
2.2.3instrument 
libinstrument       Java Instrumentation API    Agent  libinstrument            JPLISAgentJava Programming Language Instrumentation Services Agent             Java Instrumentation API    Agent         JVMTI   Java Instrumentation  API 
       JVM     JVM    -javaagent     Agent libinstrument  JVMTI Agent_OnLoad libinstrument  Agent_OnLoad 

<87
JNIEXPORT jint JNICALL DEF_Agent_OnLoad(JavaVM *vm, char *tail, void * reserved) {
initerror = createNewJPLISAgent(vm, &agent); if ( initerror == JPLIS_INIT_ERROR_NONE ) {
if (parseArgumentTail(tail, &jarfile, &options) != 0) { fprintf(stderr, "-javaagent: memory allocation failure.\n"); return JNI_ERR;
} attributes = readAttributes(jarfile); premainClass = getAttribute(attributes, "Premain-Class"); /* Save the jarfile name */ agent->mJarfile = jarfile; /*
* Convert JAR attributes into agent capabilities */ convertCapabilityAttributes(attributes, agent); /* * Track (record) the agent class name and options data */ initerror = recordCommandLineData(agent, premainClass, options); } return result; }
 libinstrument  Agent_OnLoad 
 JPLISAgent ManiFest 
Premain-Class JPLISAgent  initializeJPLISAgent
 Agent  initializeJPLISAgent 
JPLISInitializationError initializeJPLISAgent(JPLISAgent *agent, JavaVM *vm, jvmtiEnv *jvmtienv) {
/* check what capabilities are available */ checkCapabilities(agent); /* check phase - if live phase then we don't need the VMInit event */ jvmtierror = (*jvmtienv)->GetPhase(jvmtienv, &phase); /* now turn on the VMInit event */ if ( jvmtierror == JVMTI_ERROR_NONE ) {
jvmtiEventCallbacks callbacks; memset(&callbacks, 0, sizeof(callbacks)); callbacks.VMInit = &eventHandlerVMInit; jvmtierror = (*jvmtienv)->SetEventCallbacks(jvmtienv,&callbacks, sizeof(callbacks)); } if ( jvmtierror == JVMTI_ERROR_NONE ) {

88> 2019 
jvmtierror = (*jvmtienv)->SetEventNotificationMode(jvmtienv,JVM TI_ENABLE,JVMTI_EVENT_ VM_INIT,NULL);
} return (jvmtierror == JVMTI_ERROR_NONE)? JPLIS_INIT_ERROR_NONE : JPLIS_INIT_ERROR_ FAILURE; }
      callbacks.VMInit = &eventHandlerVMInit;     
 VMInit  JVM  even-
tHandlerVMInit 
Premain 
void JNICALL eventHandlerVMInit( jvmtiEnv *jvmtienv,JNIEnv *jnienv,jthread thread) {
// ... success = processJavaStart( environment->mAgent, jnienv); // ... } jboolean processJavaStart(JPLISAgent *agent,JNIEnv *jnienv) {
result = createInstrumentationImpl(jnienv, agent); /*
* Load the Java agent, and call the premain. */ if ( result ) {
result = startJavaAgent(agent, jnienv, agent->mAgentClassName, agent->mOptionsString, agent->mPremainCaller);
} return result; } jboolean startJavaAgent( JPLISAgent *agent,JNIEnv *jnienv,const char *classname,const char *optionsString,jmethodID agentMainMethod) { // ... invokeJavaAgentMainMethod(jnienv,agent->mInstrumentationImpl,agentMainM ethod, classNameObject,optionsStringObject); // ... }
Instrument invokeJavaAgentMainMethod 
 premain  Instrument 



<89

2.3 Agent
 JVM  Agent Agent 
 Agent 
Agent  Agent
 Agent 
2.3.1AttachListener
Attach  Attach Listener 
Attach Listener 
// Starts the Attach Listener thread void AttachListener::init() {
//  const char thread_name[] = "Attach Listener"; Handle string = java_lang_String::create_from_str(thread_name, THREAD); { MutexLocker mu(Threads_lock);
JavaThread* listener_thread = new JavaThread(&attach_listener_thread_ entry);
// ... } }
Attach Listener
 attach_listener_thread_entry
static void attach_listener_thread_entry(JavaThread* thread, TRAPS) { AttachListener::set_initialized(); for (;;) { AttachOperation* op = AttachListener::dequeue(); // find the function to dispatch too AttachOperationFunctionInfo* info = NULL; for (int i=0; funcs[i].name != NULL; i++) { const char* name = funcs[i].name; if (strcmp(op->name(), name) == 0) { info = &(funcs[i]); break; }} // dispatch to the function that implements this operation

90> 2019 

res = (info->func)(op, &st); //... } }

  AttachListener::dequeue     

static AttachOperationFunctionInfo funcs[] = {

{ "agentProperties", get_agent_properties },

{ "datadump",

data_dump },

{ "dumpheap",

dump_heap },

{ "load",

load_agent },

{ "properties",

get_system_properties },

{ "threaddump",

thread_dump },

{ "inspectheap",

heap_inspection },

{ "setflag",

set_flag },

{ "printflag",

print_flag },

{ "jcmd",

jcmd },

{ NULL,

NULL }

};

 Agent "load" Attach Listener
 AttachListen-
er::dequeue  dequeue 
LinuxAttachOperation* LinuxAttachListener::dequeue() { for (;;) { // wait for client to connect struct sockaddr addr; socklen_t len = sizeof(addr); RESTARTABLE(::accept(listener(), &addr, &len), s); // get the credentials of the peer and check the effective uid/guid // - check with jeff on this. struct ucred cred_info; socklen_t optlen = sizeof(cred_info); if (::getsockopt(s, SOL_SOCKET, SO_PEERCRED, (void*)&cred_info,
&optlen) == -1) {

<91
::close(s); continue; } // peer credential look okay so we read the request LinuxAttachOperation* op = read_request(s); return op; } }
 Linux 
Attach Listener  accept 
 AttachOperation 

Attach Listener ""
JVM  Attach Listener 
""
// Start Attach Listener if +StartAttachListener or it can't be started lazily
if (!DisableAttachMechanism) { AttachListener::vm_start(); if (StartAttachListener || AttachListener::init_at_startup()) { AttachListener::init(); }
} // Attach Listener is started lazily except in the case when // +ReduseSignalUsage is used bool AttachListener::init_at_startup() {
if (ReduceSignalUsage) { return true;
} else { return false;
} }
        create_vm  DisableAttachMechanismStar-
tAttachListener  ReduceSignalUsage          false  
AttachListener::init();  create_vm  vm_start 


92> 2019 
void AttachListener::vm_start() { char fn[UNIX_PATH_MAX]; struct stat64 st; int ret; int n = snprintf(fn, UNIX_PATH_MAX, "%s/.java_pid%d", os::get_temp_directory(), os::current_process_id()); assert(n < (int)UNIX_PATH_MAX, "java_pid file name buffer overflow"); RESTARTABLE(::stat64(fn, &st), ret); if (ret == 0) { ret = ::unlink(fn); if (ret == -1) { log_debug(attach)("Failed to remove stale attach pid file at %s", fn); } }
}
 Linux  /tmp/  .java_pid{pid} 
 Attach Listener AttachListen-
er::init()  create_vm 
 Attach Listener  JVM 
""
// Signal Dispatcher needs to be started before VMInit event is posted os::signal_init();
 create_vm  Attach 
""
void os::signal_init() { if (!ReduceSignalUsage) { // Setup JavaThread for processing signals EXCEPTION_MARK; Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_
Thread(), true, CHECK); instanceKlassHandle klass (THREAD, k); instanceHandle thread_oop = klass->allocate_instance_handle(CHECK); const char thread_name[] = "Signal Dispatcher"; Handle string = java_lang_String::create_from_str(thread_name,
CHECK); // Initialize thread_oop to put it into the system threadGroup Handle thread_group (THREAD, Universe::system_thread_group()); JavaValue result(T_VOID);

<93
JavaCalls::call_special(&result, thread_oop,klass,vmSymbols::object_ initializer_name(),vmSymbols::threadgroup_string_void_signature(),
thread_group,string,CHECK); KlassHandle group(THREAD, SystemDictionary::ThreadGroup_klass()); JavaCalls::call_special(&result,thread_group,group,vmSymbols::add_ method_name(),vmSymbols::thread_void_signature(),thread_oop,CHECK); os::signal_init_pd(); { MutexLocker mu(Threads_lock);
JavaThread* signal_thread = new JavaThread(&signal_thread_entry); // ... } // Handle ^BREAK os::signal(SIGBREAK, os::user_handler()); } }
JVM "Signal Dispatcher"
              "Signal Dispatcher"     signal_
thread_entry

 signal_thread_entry  Attach  "SIGBREAK"  Attach  JVM  AttachListener::is_init_trigger()

bool AttachListener::is_init_trigger() {

if (init_at_startup() || is_initialized()) {

return false;

// initialized at startup or already

initialized

}

char fn[PATH_MAX+1];

sprintf(fn, ".attach_pid%d", os::current_process_id());

int ret;

struct stat64 st;

RESTARTABLE(::stat64(fn, &st), ret);

if (ret == -1) {

94> 2019 
log_trace(attach)("Failed to find attach file: %s, trying alternate", fn);
snprintf(fn, sizeof(fn), "%s/.attach_pid%d", os::get_temp_ directory(), os::current_process_ id());
RESTARTABLE(::stat64(fn, &st), ret); } if (ret == 0) {
// simple check to avoid starting the attach mechanism when // a bogus user creates the file if (st.st_uid == geteuid()) {
init(); return true; } } return false; }
 JVM  Attach Listener
 /tmp  .attach_pid%d 
 AttachListener  init  Attach Listener 
 Attach 
 Attach Listener  Signal Dispatcher Signal Dis-
patcher  Signal Dispatcher "SIGBREAK"
 Attach Listener 
2.3.2 Agent 
 Agent  JVM 
 Agent"atta-
chAgentToTargetJvm" VirtualMachine
 attach  Agent  VirtualMachine 
attach 
public static VirtualMachine attach(String var0) throws AttachNotSupportedException, IOException {
if (var0 == null) { throw new NullPointerException("id cannot be null");

<95
} else { List var1 = AttachProvider.providers(); if (var1.size() == 0) { throw new AttachNotSupportedException("no providers
installed"); } else { AttachNotSupportedException var2 = null; Iterator var3 = var1.iterator(); while(var3.hasNext()) { AttachProvider var4 = (AttachProvider)var3.next(); try { return var4.attachVirtualMachine(var0); } catch (AttachNotSupportedException var6) { var2 = var6; } } throw var2; }
} }
 attachVirtualMachine  attach  MacOS 
AttachProvider  BsdAttachProvider BsdAttach-
Provider  attachVirtualMachine 
public VirtualMachine attachVirtualMachine(String var1) throws AttachNotSupportedException, IOException {
this.checkAttachPermission(); this.testAttachable(var1); return new BsdVirtualMachine(this, var1); } BsdVirtualMachine(AttachProvider var1, String var2) throws AttachNotSupportedException, IOException { int var3 = Integer.parseInt(var2); this.path = this.findSocketFile(var3); if (this.path == null) {
File var4 = new File(tmpdir, ".attach_pid" + var3); createAttachFile(var4.getPath()); try {
sendQuitTo(var3); int var5 = 0; long var6 = 200L; int var8 = (int)(this.attachTimeout() / var6); do {
try {

96> 2019 
Thread.sleep(var6); } catch (InterruptedException var21) {
; } this.path = this.findSocketFile(var3); ++var5; } while(var5 <= var8 && this.path == null); } finally { var4.delete(); } } int var24 = socket(); connect(var24, this.path); } private String findSocketFile(int var1) { String var2 = ".java_pid" + var1; File var3 = new File(tmpdir, var2); return var3.exists() ? var3.getPath() : null; }
findSocketFile  JVM  Attach Listener
"tmp/" java_pid{pid} 
 Attach 
 connect  JVM "load"
 Agent java_pid{pid}  sendQuitTo 
JVM "SIGBREAK" Attach Listener 
 java_pid{pid} 
 connect  JVM 
2.3.3load 
"load" JVM 
static jint load_agent(AttachOperation* op, outputStream* out) { // get agent name and options const char* agent = op->arg(0); const char* absParam = op->arg(1); const char* options = op->arg(2); // If loading a java agent then need to ensure that the java.
instrument module is loaded if (strcmp(agent, "instrument") == 0) {

<97
Thread* THREAD = Thread::current(); ResourceMark rm(THREAD); HandleMark hm(THREAD); JavaValue result(T_OBJECT); Handle h_module_name = java_lang_String::create_from_str("java. instrument", THREAD); JavaCalls::call_static(&result,SystemDictionary::module_Modules_ klass(),vmSymbols::loadModule_name(),
vmSymbols::loadModule_signature(),h_module_ name,THREAD);
} return JvmtiExport::load_agent_library(agent, absParam, options, out); }
 java.instrument  Agent   load_agent_library ,  Agent   Java instrument API  Agent libinstrument   libinstrument  agentmain  libinstrument  premain   Java Agent 
3.1
 Agent  Java Instrumentation API  Instrumentation  addTransformer                  ClassFileTransformer     ClassFileTransformer         transform            transform  Instrumentation  redefineClasses  
* The redefinition may change method bodies, the constant pool and attributes.
* The redefinition must not add, remove or rename fields or methods, change the
* signatures of methods, or change inheritance. These restrictions maybe be

98> 2019 
* lifted in future versions. The class file bytes are not checked, verified and installed
* until after the transformations have been applied, if the resultant bytes are in
* error this method will throw an exception.

 ASM 
 redefineClasses 
 redefineClasses 
 JVM  redefineClasses 

3.2
      libinstrument      JPLISAgent     
Agent  Java  JVMTI 
 Java  Java Instrumentation API  redefineClasses
libinstrument 
public void redefineClasses(ClassDefinition... var1) throws ClassNotFoundException {
if (!this.isRedefineClassesSupported()) { throw new UnsupportedOperationException("redefineClasses is
not supported in this environment"); } else if (var1 == null) { throw new NullPointerException("null passed as
'definitions' in redefineClasses"); } else { for(int var2 = 0; var2 < var1.length; ++var2) { if (var1[var2] == null) { throw new NullPointerException("element of
'definitions' is null in redefineClasses"); }
} if (var1.length != 0) {
this.redefineClasses0(this.mNativeAgent, var1); } } }

<99
private native void redefineClasses0(long var1, ClassDefinition[] var3) throws ClassNotFoundException;
  InstrumentationImpl   redefineClasses            Native  redefineClasses() libinstrument  Native 
JNIEXPORT void JNICALL Java_sun_instrument_InstrumentationImpl_ redefineClasses0
(JNIEnv * jnienv, jobject implThis, jlong agent, jobjectArray classDefinitions) {
redefineClasses(jnienv, (JPLISAgent*)(intptr_t)agent, classDefinitions); }
redefineClasses  
 JVMTI  RetransformClasses  
// class_count - pre-checked to be greater than or equal to 0 // class_definitions - pre-checked for NULL jvmtiError JvmtiEnv::RedefineClasses(jint class_count, const jvmtiClassDefinition* class_ definitions) { //TODO: add locking
VM_RedefineClasses op(class_count, class_definitions, jvmti_class_ load_kind_redefine);
VMThread::execute(&op);

100> 2019 
return (op.check_error()); } /* end RedefineClasses */
         JVM      VM_RedefineClasses    VM_ OperationVM_Operation  JVM             GC    VM_Operation  VMThread      VM_Operation        VMThread VMThread  VM_Operation   doit VM_RedefineClasses   VM_RedefineClasses 
 
// Load the caller's new class definition(s) into _scratch_classes. // Constant pool merging work is done here as needed. Also calls // compare_and_normalize_class_versions() to verify the class // definition(s). jvmtiError load_new_class_versions(TRAPS);
 
// Remove all breakpoints in methods of this class JvmtiBreakpoints& jvmti_breakpoints = JvmtiCurrentBreakpoints::get_ jvmti_breakpoints(); jvmti_breakpoints.clearall_in_class_at_safepoint(the_class());
 JIT 
// Deoptimize all compiled code that depends on this class flush_dependent_code(the_class, THREAD);
  itable/vtable   
SystemDictionary::notice_modification();
VM_RedefineClasses  RedefineClasses 

<101 Java-debug-tool  Java Instrument API   JVM  TcpServer   TcpServerTcpServer  handler handler   Java-debug-tool 
4.1Java-debug-tool 
Java-debug-tool  Java Agent  API  API  JVM   Java-debug-tool  Client-Server  Java-debug-tool  
1

102> 2019 

   
    Java-debug-tool  Java Instrumenta-
tion  API Java Instrumentation   JVMTI 
 Agent  JVM Java-debug-tool  Spy   JVM  Spy  JVM     Java-debug-tool  
4.2Java-debug-tool 
Java-debug-tool  """" Java-debug-tool   Java-debug-tool ""
   Fields  1    Fields  2    

<103 Java-debug-tool  
4.2.1
Java-debug-tool  ASM    Java-debug-tool     Java-debug-tool 
2
 2 Java-debug-tool   +     

104> 2019 
 
  Java-debug-tool 
   Advice   Advice  Java-debug-tool   Advice Advice  Java-debug-tool  AdviceAdvice   Java-debug-tool 
4.2.2Advice 
Advice  AdviceAdvice   JVM  Advice  "match"  Java-debug-tool  " Advice"->" Advice"
 Advice  JVM  JVM  Advice  Advice   Advice  Java-debug-tool 

<105
3
Advice  Java-debug-tool   Advice  Advice   Advice   Advice  Advice 
4.3Java-debug-tool 
4.3.1
 Java-debug-tool   Java-debug-tool  

106> 2019 
4
 4  Java-debug-tool         Advice  
Java-debug-tool   Java-debug-tool   Java-debug-tool   

<107
Java-debug-tool    
4.3.2 
Java-debug-tool 
      JVM  STW               
 5  Java-debug-tool 

108> 2019 
5
4.4Java-debug-tool 
Java-debug-tool  greys greys  greys  Java-debug-tool 

<109
 Java  Java    

 ASM 4 guide  Java Virtual Machine Specification  JVM Tool Interface  alibaba arthas  openjdk



 -      Java   tech@meituan.com

110> 2019 
 ReentrantLock  AQS 


Java LockSemaphoreReentrantLock  AbstractQueuedSynchronizer AQSAQS    ReentrantLock  ReentrantLock  AQS   AQS   AQS AQS  Sync Queue  Condition Queue  AQS   ReentrantLock ReentrantLock 


<111
1. ReentrantLock
1.1ReentrantLock 
ReentrantLock   ReentrantLock  ReentrantLock   Synchronized 

// **************************Synchronized  ************************** // 1.  synchronized (this) {} // 2.  synchronized (object) {} // 3.  public synchronized void test () {} // 4.  for (int i = 0; i < 100; i++) {
synchronized (this) {} } // **************************ReentrantLock  **************************

112> 2019 
public void test () throw Exception { // 1.  ReentrantLock lock = new ReentrantLock(true); // 2.  lock.lock(); try { try { // 3.  ;  if(lock.tryLock(100, TimeUnit.MILLISECONDS)){ } } finally { // 4.  lock.unlock() } } finally { lock.unlock(); }
}
1.2ReentrantLock  AQS 
ReentrantLock 
 Java"" ReentrantLock
 AQS  ReentrantLock 
 AQS   AQS 
 AQS 

// java.util.concurrent.locks.ReentrantLock#NonfairSync
//  static final class NonfairSync extends Sync {
... final void lock() {
if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread());
else acquire(1);
} ... }


<113
  CAS  State 
  CAS  State Acquire 
 
  1
 AQS  2    1       

// java.util.concurrent.locks.ReentrantLock#FairSync
static final class FairSync extends Sync { ... final void lock() { acquire(1); } ...
}
Lock  Acquire 

114> 2019 
 
Acquire  Acquire  FairSync  UnfairSync  AQS  
 ReentrantLock   Acquire  AbstractQueuedSynchronizer  ----AQS AQS  ReentrantLock  AQS   2.3.5 
2. AQS
 AQS 

<115
  Method Attribution  AQS  AQS 
API   
  API  AQS     AQS  
2.1
AQS    CLH  
CLHCraigLandin and Hagersten AQS  CLH FIFOAQS  


116> 2019 

AQS  Volatile  int  FIFO  CAS  State 
2.1.1AQS   AQS ----NodeNode  CLH  







waitStatus 

thread



prev



predecessor  npe

nextWaiter

 CONDITION  Condition Queue 

next





 SHARED

 

EXCLUSIVE 

waitStatus 

<117





0

 Node 

CANCELLED  1

CONDITION  -2

PROPAGATE  -3 SHARED 

SIGNAL

 -1

2.1.2 State  AQS ----StateAQS   state  Volatile  
// java.util.concurrent.locks.AbstractQueuedSynchronizer
private volatile int state;



 protected final int getState() protected final void setState(int newState) protected final boolean compareAndSetState(int expect, int update)

  State   State   CAS  State

 Final  State 

118> 2019 

<119

  AQS API 

2.2AQS  ReentrantLock 
AQS  Protected   State  ReentrantLock  

 protected boolean isHeldExclusively()

  Condition  

protected boolean tryAcquire(int arg 

arg)

 True False

protected boolean tryRelease(int arg 

arg)

 True False

protected int tryAcquireShared(int arg)

arg  0  

protected boolean tryReleaseShared(int arg)

arg   True False

                               tryAcquire-tryReleasetryAcquireShared-tryReleaseShared      AQS  ReentrantReadWriteLockReentrantLock  tryAcquire-tryRelease
 AQS  

120> 2019 
 ReentrantLock  AQS  

<121
   ReentrantLock  Lock          Sync  Lock     Sync#lock       
ReentrantLock  Lock   AQS  Acquire   AQS  Acquire  tryAcquire  tryAcquire   ReentrantLock  tryAcquire  ReentrantLock  tryAcquire 

122> 2019   tryAcquire
 tryAcquire  AQS  ReentrantLock 
    ReentrantLock  Unlock   Unlock  Sync  Release  AQS  Release     tryRelease  tryRelease          
tryRelease  ReentrantLock  Sync     AQS   ReentrantLock  API  
2.3 ReentrantLock  AQS
ReentrantLock  

// java.util.concurrent.locks.ReentrantLock static final class NonfairSync extends Sync {
... final void lock() {

<123

} ... }

if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread());
else acquire(1);

 Acquire 
// java.util.concurrent.locks.AbstractQueuedSynchronizer
public final void acquire(int arg) { if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();
}

 tryAcquire 
// java.util.concurrent.locks.AbstractQueuedSynchronizer
protected boolean tryAcquire(int arg) { throw new UnsupportedOperationException();
}

 AQS   ReentrantLock  True  
2.3.1 2.3.1.1  Acquire(1)  tryAcquire   addWaiter  2.3.1.2  addWaiter(Node.EXCLUSIVE)  

124> 2019 
// java.util.concurrent.locks.AbstractQueuedSynchronizer
private Node addWaiter(Node mode) { Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) { node.prev = pred; if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } enq(node); return node;
} private final boolean compareAndSetTail(Node expect, Node update) {
return unsafe.compareAndSwapObject(this, tailOffset, expect, update); }

 
 Pred  Tail
  New  Node  Prev  Pred
   compareAndSetTail                  
tailOffset  Expect  tailOffset  Node  Expect  Node
 Tail  Update 
// java.util.concurrent.locks.AbstractQueuedSynchronizer
static { try { stateOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.
class.getDeclaredField("state")); headOffset = unsafe.
objectFieldOffset(AbstractQueuedSynchronizer.class. getDeclaredField("head"));
tailOffset = unsafe. objectFieldOffset(AbstractQueuedSynchronizer.class. getDeclaredField("tail"));
waitStatusOffset = unsafe.objectFieldOffset(Node.class. getDeclaredField("waitStatus"));

<125
nextOffset = unsafe.objectFieldOffset(Node.class. getDeclaredField("next"));
} catch (Exception ex) { throw new Error(ex); } }
 AQS   tailOffset  tail  new  Node  
  Pred  Null Pred  Tail  Enq 
// java.util.concurrent.locks.AbstractQueuedSynchronizer
private Node enq(final Node node) { for (;;) { Node t = tail; if (t == null) { // Must initialize if (compareAndSetHead(new Node())) tail = head; } else { node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } }
}
  addWaiter   

126> 2019 
 1.  1  2.  2  1 
3.  hasQueuedPredecessors   False  True
// java.util.concurrent.locks.ReentrantLock public final boolean hasQueuedPredecessors() {
// The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue. Node t = tail; // Read fields in reverse initialization order Node h = head; Node s; return h != t && ((s = h.next) == null || s.thread != Thread. currentThread()); }
 h != t && ((s = h.next) == null || s.thread != Thread. currentThread());  
  h != t  (s =

<127
h.next) == null Tail   Head Head  Tail True   (s = h.next) != null  s.thread == Thread.currentThread()   s.thread != Thread.currentThread() 
// java.util.concurrent.locks.AbstractQueuedSynchronizer#enq
if (t == null) { // Must initialize if (compareAndSetHead(new Node())) tail = head;
} else { node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; }
}
 head != tail Tail        Tail   Head   Head     Tail  567   
2.3.1.3 
// java.util.concurrent.locks.AbstractQueuedSynchronizer
public final void acquire(int arg) { if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();
}
 addWaiter  Node   Node Node 

128> 2019 
 acquireQueued acquireQueued 
""
acquireQueued 

"""" acquire-
Queued 
// java.util.concurrent.locks.AbstractQueuedSynchronizer
final boolean acquireQueued(final Node node, int arg) { //  boolean failed = true; try { //  boolean interrupted = false; //  for (;;) { //  final Node p = node.predecessor(); //  p 
 if (p == head && tryAcquire(arg)) { //  node setHead(node); p.next = null; // help GC failed = false; return interrupted; } //  p 
 p  node  waitStatus  -1
if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())
interrupted = true; } } finally { if (failed)
cancelAcquire(node); } }
setHead  waitStatus


<129
// java.util.concurrent.locks.AbstractQueuedSynchronizer
private void setHead(Node node) { head = node; node.thread = null; node.prev = null;
}
// java.util.concurrent.locks.AbstractQueuedSynchronizer
//  private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
//  int ws = pred.waitStatus; //  if (ws == Node.SIGNAL)
return true; //  waitStatus>0  if (ws > 0) {
do { //  node.prev = pred = pred.prev;
} while (pred.waitStatus > 0); pred.next = node; } else { //  SIGNAL compareAndSetWaitStatus(pred, ws, Node.SIGNAL); } return false; }
parkAndCheckInterrupt 

// java.util.concurrent.locks.AbstractQueuedSynchronizer
private final boolean parkAndCheckInterrupt() { LockSupport.park(this); return Thread.interrupted();
}


130> 2019 
" " CPU  shouldParkAfterFailedAcquire 

<131
  shouldParkAfterFailedAcquire 
 waitStatus  -1    2.3.2CANCELLED  acquireQueued  Finally 
// java.util.concurrent.locks.AbstractQueuedSynchronizer final boolean acquireQueued(final Node node, int arg) {
boolean failed = true; try {

132> 2019 
... for (;;) { final Node p = node.predecessor(); if (p == head && tryAcquire(arg)) { ... failed = false;
... } ...
} finally { if (failed) cancelAcquire(node); }
}
  cancelAcquire    Node       CANCELLED   

// java.util.concurrent.locks.AbstractQueuedSynchronizer
private void cancelAcquire(Node node) { //  if (node == null) return; //  node.thread = null; Node pred = node.prev; //  node while (pred.waitStatus > 0) node.prev = pred = pred.prev; //  Node predNext = pred.next; //  node  CANCELLED node.waitStatus = Node.CANCELLED; //  //  else tail  null if (node == tail && compareAndSetTail(node, pred)) { compareAndSetNext(pred, predNext, null); } else { int ws; //  head 1:  SIGNAL
2:  SINGAL  //  1  2  true null //  if (pred != head && ((ws = pred.waitStatus) == Node.SIGNAL
|| (ws <= 0 && compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) && pred.thread != null)

<133
{ Node next = node.next; if (next != null && next.waitStatus <= 0) compareAndSetNext(pred, predNext, next);
} else { //  head  
unparkSuccessor(node); } node.next = node; // help GC } }

  CANCELLED  waitStatus <= 0  Pred  Node  Node  CANCELLED

1 2 Head  3 Head 
 

134> 2019   Head   Head 

<135
 CANCELLED   Next  Prev   Prev 
  cancelAcquire   Try  shouldParkAfterFailedAcquire   Prev  Prev  Node  Prev  shouldParkAfterFailedAcquire                 Prev  shouldParkAfterFaile-
dAcquire   Prev  
do { node.prev = pred = pred.prev;
} while (pred.waitStatus > 0);
2.3.3 

136> 2019 
 ReentrantLock 

// java.util.concurrent.locks.ReentrantLock
public void unlock() { sync.release(1);
}

// java.util.concurrent.locks.AbstractQueuedSynchronizer
public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null && h.waitStatus != 0) unparkSuccessor(h); return true; } return false;
}
 ReentrantLock  Sync 

// java.util.concurrent.locks.ReentrantLock.Sync
//  protected final boolean tryRelease(int releases) {
//  int c = getState() - releases; //  if (Thread.currentThread() != getExclusiveOwnerThread())
throw new IllegalMonitorStateException(); boolean free = false; //  null state if (c == 0) {
free = true; setExclusiveOwnerThread(null); } setState(c); return free; }

<137



// java.util.concurrent.locks.AbstractQueuedSynchronizer

public final boolean release(int arg) { //  tryRelease  true

if (tryRelease(arg)) { // 



Node h = head; //  waitStatus 

if (h != null && h.waitStatus != 0)

unparkSuccessor(h);

return true;

}

return false;

}

 h != null && h.waitStatus != 0 
h == null Head head == null
Head 
 head == null 
h != null && waitStatus == 0 

h != null && waitStatus < 0 
 unparkSuccessor 
// java.util.concurrent.locks.AbstractQueuedSynchronizer
private void unparkSuccessor(Node node) { //  waitStatus int ws = node.waitStatus; if (ws < 0) compareAndSetWaitStatus(node, ws, 0); //  Node s = node.next; //  null  cancelled
cancelled  if (s == null || s.waitStatus > 0) { s = null; //  waitStatus<0 

138> 2019 
for (Node t = tail; t != null && t != node; t = t.prev) if (t.waitStatus <= 0) s = t;
} //  <=0 unpark if (s != null)
LockSupport.unpark(s.thread); }
 Cancelled 
 addWaiter 
// java.util.concurrent.locks.AbstractQueuedSynchronizer
private Node addWaiter(Node mode) { Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) { node.prev = pred; if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } enq(node); return node;
}
                       node.prev =
pred; compareAndSetTail(pred, node)  Tail 
 pred.next = node;  unparkSuccessor
                             
CANCELLED  Next Prev 
 Node
                           
CANCELLED          Next               
                              

<139
acquireQueued 
2.3.4  return Thread.interrupted();

// java.util.concurrent.locks.AbstractQueuedSynchronizer
private final boolean parkAndCheckInterrupt() { LockSupport.park(this); return Thread.interrupted();
}
   acquireQueued    parkAndCheckInterrupt   True  
False interrupted 
 interrupted 
// java.util.concurrent.locks.AbstractQueuedSynchronizer
final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor(); if (p == head && tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return interrupted; } if (shouldParkAfterFailedAcquire(p, node) &&
parkAndCheckInterrupt()) interrupted = true;
} } finally {
if (failed) cancelAcquire(node);
} }
 acquireQueued  True selfInterrupt 

140> 2019 
// java.util.concurrent.locks.AbstractQueuedSynchronizer static void selfInterrupt() {
Thread.currentThread().interrupt(); }
  Java 
1.   Thread.interrupted()   False
2.   
 Worder  runWorker  Thread.interrupted()  ThreadPoolExecutor 
2.3.5  1.3 
Q A  Q  A CLH  FIFO  Q A 2.3.1.3 

<141
Q  A  2.3.2  QLock  Acquire  AAQS  Acquire  tryAcquire tryAcquire   tryAcquire 
3. AQS 
3.1ReentrantLock 
ReentrantLock  AQS   ReentrantLock  ReentrantLock  

// java.util.concurrent.locks.ReentrantLock.FairSync#tryAcquire
if (c == 0) { if (!hasQueuedPredecessors() && compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; }
} else if (current == getExclusiveOwnerThread()) {
int nextc = c + acquires; if (nextc < 0)
throw new Error("Maximum lock count exceeded"); setState(nextc); return true; }

// java.util.concurrent.locks.ReentrantLock.Sync#nonfairTryAcquire
if (c == 0) { if (compareAndSetState(0, acquires)){

142> 2019 

setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc < 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; }

 State  State  Volatile 
// java.util.concurrent.locks.AbstractQueuedSynchronizer private volatile int state;

 State  1. State  0 2.  +1
 +1 3.  -1 0

3.2JUC 
 ReentrantLock AQS   JUC   AQS 



AQS

ReentrantLock

 AQS ReentrantLock  

Semaphore

 AQS tryRelease  acquireShared 

 AQS  0  Acquire  CountDownLatch
CountDownLatch  await 

<143

 ReentrantReadWriteLock ThreadPoolExecutor

AQS  AQS  16  16   Worker  AQS tryAcquire  tryRelease

3.3
 AQS  AQS 

public class LeeLock {
private static class Sync extends AbstractQueuedSynchronizer { @Override protected boolean tryAcquire (int arg) { return compareAndSetState(0, 1); }
@Override protected boolean tryRelease (int arg) {
setState(0); return true; }
@Override protected boolean isHeldExclusively () {
return getState() == 1; } }
private Sync sync = new Sync();
public void lock () { sync.acquire(1);
}
public void unlock () { sync.release(1);
} }
 Lock 

144> 2019 
public class LeeMain {
static int count = 0; static LeeLock leeLock = new LeeLock();
public static void main (String[] args) throws InterruptedException {
Runnable runnable = new Runnable() { @Override public void run () { try { leeLock.lock(); for (int i = 0; i < 10000; i++) { count++; } } catch (Exception e) { e.printStackTrace(); } finally { leeLock.unlock(); }
} }; Thread thread1 = new Thread(runnable); Thread thread2 = new Thread(runnable); thread1.start(); thread2.start(); thread1.join(); thread2.join(); System.out.println(count); } }
 20000
 AQS 


 ReentrantLock  AQS 
 AQS  ReentrantLock ""

<145

 Lea D. The java. util. concurrent synchronizer framework[J]. Science of Computer Programming, 2005, 58(3): 293-309.
 Java    Java""

 Java 2018 

  12  3   300  1   2018    tech@meituan. com

146> 2019 



 Kubernetes 



" """   
 Kubernetes  Kubernetes Kubernetes  

""2013  2015  7  ----HULK2016  Docker    IT 2018  Kubernetes  

<147

 Docker     Docker  ""----HULK HULK1.0
   2  HULK 1.0   HULK   Kubernetes  Kubernetes  Kubernetes ----HULK2.0

HULK2.0  Kubernetes    Kubernetes   Kubernetes  Kubernetes API  Kubernetes

148> 2019   

HULK2.0 
  OPS  Portal HULK   ,  HULK API  HULK  HULK HULK API   HULK 

<149
 Kubernetes HULK  IP  Hostname  Kubernetes  Kubernetes API   Kubernetes Kubernetes API  HULK   Kubernetes API 
HULK API  Kubernetes API  
Kubernetes 
 Kubernetes  Kubernetes   Docker Swarm  Mesos  Kubernetes     

150> 2019 
HULK-Kubernetes 
Kubernetes  HULK  

 10  +   container-init 
   NodePod  Container 
 Node Container   
D  AppKey  Pod  

<151  Pod 
  Pod    
Kubernetes 
kube-scheduler 
 1.6  Kubernetes 1.10   3000  Pod   5s Kubernetes   Pod  Pod    400% 
Kubernetes 
kube-scheduler 

152> 2019  kubernetes 

 Node    Predicates
 Predicate  Node   Priorities  Priority    Select Node  Pod 
kube-scheduler 
 Node  Node  
"" Node 



<153

kube-scheduler  Predicates 
           Kubernetes   (   PR)    alwaysCheckAllPredicates  Kubernetes1.10   alwaysCheckAllPredicates=true  
               40%             Kube-scheduler  1.10

  

154> 2019   
kube-scheduler 
 Node  BestFit  Node  Node  Node 
 1000  Node PodA 700  Node   Predicates Node  700  Node Node  NodeX  N  Node N  Node  Node 

<155
 100  Predicates Node   100  Node  NodeX  100  Node  100  Node  NodeY   100  Node  100  Node 200  300  Node  
  (  PR1PR2) Kubernetes 1.12   
kubelet 

 Kubelet  Kubelet   Kubelet    Kubelet  
 Kernel  Kernel    Kubelet  ReuseRebuild 

156> 2019 
IP   CNI  Pod   IP IP  Pod  
  Kubelet    Kubelet   
 
 Kubelet  Numa  CPUShare  CPUSet 
  ulimit io limitpid limitswap 
     Kubernetes     Pod               Pod  IP  HostName   
 

<157 
  Site   Site 
    
 P2P   P2P  



158> 2019 

  CPU I/O   
   
     CPU  CPU Set   
  
   Numa CPU Set 

 
   CPU Set   CPU  CPU  

<159
  
     
  TorZone 
  
  GPUSSD 

   
 Numa  Numa       CPU  Memory        Numa Node     Node 
 CPU Set  CPU   CPU 
   SLA
  SLA

160> 2019 
  
SLA


  -    SLA  



  IT  Kubernetes    IT  Kubernetes  Linux   tech@meituan.com 

<161
 HULK 

 /  2019 QCon  Kubernetes   Kubernetes 

HULK  HULK   VM 
    5 
   HULK  
HULK   HULK  """ ""HULK"
 HULK  1.0  2.0 

162> 2019 
HULK 1.0  OpenStack   CMDB   2018  OpenStack  Kubernetes  HULK 2.0 1.0  
       1  10 

HULK2.0 

<163

 CMDB   VM 
    CPU/IO 
  
 HULK Agent  Node    

3.1
 

164> 2019 
 a.  b.  c.  API  K8s  K8s  Master  Work d.  Node  IP  Hostname  IP e. Container-init  Agent     traceId TaskId  TaskId

<165
 HULK Portal  
  1 
 
3.2
 

                    swap   memlock ulimit 
 ZooKeeper 
 

166> 2019    Set     N+1  IDC     Manifest  Kuber-
netes  YAML  
3.3
 Kubernetes  Scheduler   ApiServer ApiServer  Bind  Pod   Node Bind  Predicates  Priorities 
Predicates PodFitsResources   CPU Pod   Node
Priorities 

<167  LeastRequestedCPU 
  BalancedResourcesAllocationCPU  0-10   3000  Pod  5s K8s 1.6  Node   Node    Node   Node 
 40%  1.10   GitHub  PR
 SLA 

168> 2019  

 Pod  Pod   N    SLA
3.4
 1 /      IP 

<169 2Kubelet   1 /    Reuse Rebuild   CNI  Pod  IP 2


Raptor  CATFalcon   5 

170> 2019 
4.1
 2  1    QPSCPU
    5  2  10  10  5  2   
4.2

<171   12   8  TaskId  TaskId   8  28   20  
4.3
 30  3 ABC     
  

172> 2019 
4.4
 2  20  15   30  50   
 1 80% 2  
4.5

<173
 1:00:00~1:01:00   1:01:10  70s+ 30s+  100s+
   1~2 

  "" Kubernetes 
  
   SLA 
 SLA 
   VM 
   HULK HULK 




Base     tech@meituan.com

174> 2019 
 IDC  HIDS 


 IDC   IDC   Host-based Intrusion Detection System HIDS HIDS   IDC  

 HIDS 
1.  50W-100W  IDC  2.  Agent  3.  4.  5.  Agent 
 6. Agent  Server  7.  8.  9. Agent 

HIDS Agent 

<175
  Agent 
 Agent   1-2  30 20  
 Agent  HIDS  Agent   Agent 
Agent  Agent 
 Agent    

1.  2.  3.  4.  5.  Linux  6.  CPU 7.  8. 

 

176> 2019    CPU   Agent       Agent     


 Agent     CAP 
CAP-theorem.png

<177
CAP 
 CAP 
 Consistency  Availability  Partition Tolerance
 
                               CAP   Consistency  Availability  Consistency  Availability Partition Tolerance
CAP Theorem
CAP 
                         Partition tolerance AP  CP
 HIDS  Agent    Agent   CP 
 CP 
 CP  etcdZooKeeper Consul  

178> 2019   Consul  AP  Consul
Partition tolerance    consul             Consul uses a CP architecture, favoring consistency over availability.
Consul is opinionated in its usage while Serf is a more flexible and general purpose tool. In CAP terms, Consul uses a CP architecture, favoring consistency over availability. Serf is an AP system and sacrifices consistency for availability. This means Consul cannot operate if the central servers cannot form a quorum while Serf will continue to function under almost all circumstances.
etcdZooKeeperConsul 
 etcd  etcd  ZooKeeper  Consul 
etcd-ZooKeeper-Consul
 HIDS Agent       Key  etcd   KubernetesAWSOpenStackAzure Google CloudHuawei Cloud  etcd 

 etcd  HIDS 

<179

 etcd
 etcd  API  
 Watch    etcd etcd  N/2+1 
 Leader Member     Golang Client SDK   Key  Key   UserRole  Key   Key   TLS   Txn  API  Compare API  Key   Lease  Key   etcd  Key  BTree  O n  Key 

etcd Key 

 Server  /hids/server/config/{hostname}/master  Agent  /hids/agent/master/{hostname}  Plugin  /hids/agent/config/{hostname}/plugin/ID/conf_name
Server Watch /hids/server/config/{hostname}/master Agent  Agent Watch /hids/server/config/{hostname}/ 

180> 2019 
Agent  Key  Lease Id keepalive  1/3  keepalive 
 Key  Role  User  Key 
etcd 
 etcd  DNS    N  etcd   N/2-1    
 IP IPIP  DNS  Member  Discover  DNS  
 etcd  DNS   IP
1. IP  DNS  2. 
 TLS   IP DNS 
etcd Cluster 
etcd  Client   IP  IP etcd Node

<181 List etcd Cluster  TLS 
 HIDS 
hids-cluster-architecture
 AgentServer   Server  Agent 
 Server Agent etcd 

                             

182> 2019 
Linux  Windows  Golang  
1.  syscall  libc  Linux 
2.  3.  GC  4.  Golang  KubernetesDocker  5. etcd  Golang SDK  6.  CSP 

HIDS  
      Agent     Hook   

 



<183

hids-framework
 Interface etcd Client Logger App  App 

  App Loggeretcd Client   App  sandbox   App  
IConfig
 App  IConfig   Check  
 Reflect  JSON  Config   Struct  JSON 

184> 2019 
 Config  Struct 
type IConfig interface { Check() error // 
}
func ConfigLoad(confByte []byte, config IConfig) (IConfig, error) { ... //  IConfig
var confTmp IConfig confTmp = reflect.New(reflect.ValueOf(config).Elem().Type()). Interface().(IConfig) ...
//  confTmp  confTmpReflect := reflect.TypeOf(confTmp).Elem() confTmpReflectV := reflect.ValueOf(confTmp).Elem()
//  config IConfig configReflect := reflect.TypeOf(config).Elem() configReflectV := reflect.ValueOf(config).Elem() ... for i = 0; i < num; i++ { //  Field
envStructTmp := configReflect.Field(i) //  if envStructTmp.Type == confStructTmp.Type {
configReflectV.FieldByName(envStructTmp.Name). Set(confTmpReflectV.Field(i))
TimerClock 


clock_gettime  CPU  

 100ms200ms 1s 

 Ticker Ticker 
 Ticker CPU 

<185
Catcher
 panic   

         Sandbox  InitRunShutdown      App  App App   PID  App  Context   Sync.Cond  App   App 

 IO
         
 IO
 /usr/include/sys/syslog.h
 LOG_EMERG  LOG_ALERT  LOG_CRIT  LOG_ERR  LOG_WARNING

186> 2019 
 LOG_NOTICE  LOG_INFO  LOG_DEBUG
 
 2  20M50M 
IRetry
 Agent  RPC  Agent  etcd Cluster  TCP HTTP2 Agent   Agent      Agent  Agent  
//  Interface type INetRetry interface {
//  Connect() error String() string //  GetMaxRetry() uint ... } //  func (this *Context) Retry(netRetry INetRetry) error { ... maxRetries = netRetry.GetMaxRetry() //  hashMod = netRetry.GetHashMod() for { if c.shutting {
return errors.New("c.shutting is true...")

<187
} if maxRetries > 0 && retries >= maxRetries {
c.logger.Debug("Abandoning %s after %d retries.", netRetry.String(), retries)
return errors.New("  ") } ... if e := netRetry.Connect(); e != nil {
delay = 1 << retries if delay == 0 {
delay = 1 } delay = delay * hashInterval ... c.logger.Emerg("Trying %s after %d seconds , retries:%d,error:%v", netRetry.String(), delay, retries, e) time.Sleep(time.Second * time.Duration(delay)) } ... }

 IDC  Agent 





 etcd  Metrics 
Prometheus  Grafana  Alert
 IM
Agent  Watch 
Active Streams etcd
Watch  Key  Agent 

188> 2019  Agent  Agent  Watch  Key 
etcd-Grafana-Watcher-Monitor
etcd  Members 
etcd-Grafana-GC-Heap-Objects
 etcd  Member Leader  GC  



<189

agent-mem-es

agent-cpu-es

190> 2019 
 Agent  CPU\  Agent  
  
  ID   ID   


     


  Agent CPU  N   5% 
 Master  Ticker    App 

 etcd Key  Agent  Key  Agent 



<191


 log_agent  VM Docker  log_agent  Kafka  Hive 


 etcd  Agent   CPU 
 BUG  Agent 



 linux  

 Docker 





cn_proc  Docker 

 PID /proc/  


Audit  Docker 

 cn_proc

 Auditd

Hook 







  Agent  
  Netlink              :kernel-proc-connector-and-containers

192> 2019 
process-connector

 cn_proc  Autid cn_proc   CPU
 Hook  HOOK syscall   Bug IDC 

 cn_proc  Docker  Hook  Linux 


 PID  Docker  PID  PID  /proc/ Bash 
 Linux Kernel Netlink  cn_proc 

<193
 Bash  
 Docker  Docker  
  Netlink 
 ParseNetlinkMessage   Buff    
""  Docker  50  Docker  Docker   10M   200M   Debug  ParseNetlinkMessage  PID  Golang GC  CPU  linux/ connector.h  struct cb_msglinux/cn_proc.h  struct proc_event   Golang  GC   GC  debug.FreeOSMemory
FreeOSMemory forces a garbage collection followed by an attempt to return as much memory to the operating system as possible. (Even if this is not called, the runtime gradually returns memory to the operating system in a background task.)  PID

194> 2019 
 FreeOSMemory 
  CPU 
 sync.Pool    15M 
 Golang GC   CPU 


1. etcd Client Lease Keepalive  Bug 2. Agent  Cgroup  Bug 3. Docker  4.  Nginx  TCP 
 5.  10W  fd
   
  
 

<195

  
 syscall hook  Hook  Hook  
    SRE  
 
  


1. https://en.wikipedia.org/wiki/CAP_theorem 2. https://www.consul.io/intro/vs/serf.html 3. https://golang.org/src/runtime/debug/garbage.go?h=FreeOSMemory#L99 4. https://www.ibm.com/developerworks/cn/linux/l-connector/ 5. https://www.kernel.org/doc/ 6. https://coreos.com/etcd/docs/latest/

196> 2019 

2017  

  IDC   CVE"" Black Hat   Web    IDC   / Server  /  JVM/JS V8Web " +  "    

 Web&  &  &   zhaoyan17@meituan.com https://mp.weixin.qq.com/s/ynEq5LqQ2uBcEaHCu7Tsiw
 MTSRC security.meituan.com

<197
Leaf ID 

Leaf  ID              "There are no two identical leaves in the world."Leaf   Leaf  ID Leaf  Github  https://github.com/Meituan-Dianping/Leaf 
Leaf 
Leaf 
1.  ID ID  2.  MySQL 
 3.  CentOS 4C8G  QPS  5W+
TP99  1ms  4.  RPC  HTTP 
Leaf 
Leaf                 ID     DB    N  Server Server  DB  ID List  ID  Leaf  DB  ID List ID   ID  ID 

198> 2019 
 ID  DB 


 Leaf Server 1 DB  [11000]  Leaf Server 2 DB  [10012000]  Leaf Server 3 DB  [20013000]     Round-robin      Leaf Server           Client  ID 110012001210022002...... 12100120012002200334...... Leaf Server   DB  Leaf 

+-------------+--------------+------+-----+-------------------+------

-----------------------+

| Field

| Type

| Null | Key | Default

| Extra

|

<199

+-------------+--------------+------+-----+-------------------+------

-----------------------+

| biz_tag

| varchar(128) | NO | PRI |

|

|

| max_id

| bigint(20) | NO |

| 1

|

|

| step

| int(11)

| NO |

| NULL

|

|

| desc

| varchar(256) | YES |

| NULL

|

|

| update_time | timestamp | NO |

| CURRENT_TIMESTAMP | on update

CURRENT_

TIMESTAMP |

+-------------+--------------+------+-----+-------------------+------

-----------------------+

Leaf Server  SQL 
Begin UPDATE table SET max_id=max_id+step WHERE biz_tag=xxx SELECT tag, max_id, step FROM table WHERE biz_tag=xxx Commit

V1  DB  
1.  DB  DB  
2.  DB  DB  

Leaf  Buffer 
Leaf  Buffer   DB  Buffer   DB  Buffer  Leaf 

200> 2019 
Leaf  1.  Leaf  DB  10
 10  1  2.  DB
 ID 
Leaf  Step
 QPS  Q L T Q * T = L  L  Q T  Leaf   T  L  Q T   Leaf  T  step  nextStep
 T < 15minnextStep = step * 2  15min < T < 30minnextStep = step  T > 30minnextStep = step / 2 

<201  Leaf  DB   ID  DB
MySQL 
 MySQL Leaf  DB   Zebra  MHA  MySQL Group Replication
Leaf  
   
Leaf 
Leaf  Web   buffer  ID   Web 
Leaf Snowflake
SnowflakeTwitter  ID  64   Snowflake  ID 

202> 2019 
  1  0   2-42    43-52  workerID Server  ID    53-64  ID  +  +  ID  ID    Leaf    Java         Zookeeper               Zookeeper          Leaf      Zookeeper  workerID  workerID  ZooKeeper   SLA

 Leaf  MySQL  MySQL  Leaf Key  Leaf  Leaf   Leaf Key  Leaf  Shutdown  Leaf Key   MySQL  Key List 
  Leaf Key  Leaf  ID Leaf   Leaf   Leaf Key 

<203

 ID Leaf  ID 
  ID  MySQL  
 Snowflake ID 
 ID  
Leaf  Github https://github.com/Meituan-Dianping/Leaf  Github issues

204> 2019 
  OCTO 

 OCTO   OCTO  /  
 OCTO  OCTO-RPCOCTO-NSOCTO-Portal  OCTO-RPCOCTO-NSOCTO-Portal 

OCTO  2014  
 "" 
  
  
  ----OCTOOCTO Octopus  OCTO   

<205
OCTO   ""OCTO    OCTO 

OCTO     SET   
OCTO 
  /         
  
  
  

206> 2019  
   
 QoS   
OCTO 
OCTO 
 OCTO-RPC Java/C++ RPC  JavaC++ Node.js 
 SGAgent /  
 OceanusHTTP  Oceanus HTTP 
 OCTO-NS SDKJava/C++ SGAgent NSC Scanner 

<207
  Watt  MCC  OCTO-Portal

OCTO 
OCTO OCTO-RPC OCTO-NSOCTO-Portal 
OCTO-RPC
 OCTO   90% Java/C++  Java  C++ OCTO-RPC
OCTO-NS
 /    SDKJava/C++ SGAgent  NSC Scanner : OCTO-NS
OCTO-Portal
  : OCTO-Portal

208> 2019 
OCTO-Portal 

OCTO   OCTO   99.999% SOA  OCTO  

 OCTO 
1.  AP  2. RPC 
 3. Service Mesh / 
 OCTO 

2015 

<209
2017 

 OCTO  C++/Java  Service Mesh   tech@meituan.com

210> 2019 
 OCTO2.0 

 2019 QCon  Service Mesh 
OCTO 
OCTO   OCTO  
  90%  
  /    SET 
  

  Java 80%   Java   10   
  

<211  Bug        
 Service Mesh Service Mesh   Sidecar  Sidecar  Sidecar  Sidecar  
 Service Mesh   Sidecar  
  Sidecar  SDK  
  SDK 

212> 2019 
 Service Mesh   Sidecar   
 Mesh   Mesh  OCTO  OCTO2.0 OCTO Mesh

2.1OCTO Mesh 
 Service Mesh  2018    Mesh   Service Mesh  
 OCTO       5                   Service Mesh  
  
  N  
 

<213
 Envoy  
 Envoy  Filter  xDS 
 
  Istio  Kubernetes  Istio API 
 Istio   Kubernetes  
 Istio  OCTO  
 

214> 2019 
2.2OCTO Mesh 
 OCTO Mesh   SDK  
  SDK   OCTO Proxy Sidecar  OCTO Proxy 1
 1   OCTO Proxy  UNIX Domain Socket 
 Istio  iptables   Kubernetes  iptables  iptables  OCTO Proxy  TCP     OCTO Proxy   LEGO Agent  OCTO Proxy   Istio  Pilot Agent

<215   xDS
 xDS  
       Adcore       Adcore PilotAdcore Dispatcher  Mesh  Meta Server  
 Adcore Pilot  
 Adcore Dispatcher   Mesh 
  Envoy  P2P OCTO Mesh  
  
  Mesh  

216> 2019    Istio  Kubernetes OCTO Mesh   Meta Server  Mesh 

 Mesh    /      Mesh    Mesh   
3.1 Mesh 
 Istio   Istio  

<217  
     P2P 
 Adcore Pilot  Meta Server  Pilot        SessionMgrSnapshotDiplomat       SessionMgr  Snapshot  SessionMgr  Diplomat    Pilot   Sidecar  SessionMgr   OCTO Proxy  Pilot   Meta Server 

218> 2019 
Meta Server  Pilot  OCTO Proxy  Pilot  Meta Server  Meta Server   Pilot  Pilot  OCTO Proxy   OCTO Proxy   Pilot  OCTO Proxy  Pilot Meta Server 

<219
Mesh  Pilot   Zookeeper  OCTO Proxy  Pilot 
 100   100  Watcher  1000   100*1000 = 100000  Watcher 1000    
 OCTO Proxy   Snapshot  Snapshot  3 Data Cache  Node Snapshot  Ability Manager   OCTO Proxy
 1000  100  Watcher  Watcher  Data Cache  1000  OCTO Proxy  Pilot 

220> 2019  Snapshot 
  Envoy-Control-Plane Envoy-Control-Plane  xDS   
Meta Server   Pilot Proxy   Snapshot 
Istio  Envoy  Envoy  P2P   N  N  
 P2P  Scanner  Scanner   Pilot  Scanner Pilot  eDS  Proxy N 

<221
Google  Traffic Director    GC  Double Check 
 
3.2
OCTO Mesh  Mesh  Istio  Kubernetes   Etcd  10     Pilot  Pilot  Pilot   Pilot 
  Meta Server 

222> 2019  
 Pilot  Fetch   Mafka  Adcore Dispatcher   Pilot  Pilot  Proxy  Meta ServerMeta Server  Dispatcher Pilot  Dispatcher  
3.3
Service Mesh """"   

<223
xDS   Envoy    Mock-Sidecar  Mock-Sidecar   Step  Step YAML  Step   YAML  Sidecar  YAML 
3.4

224> 2019 
 Proxy  OCTO Proxy   LEGO Proxy  LEGO   DB LEGO Agent  Poll   LEGO Agent  OCTO Proxy

4.1
    Mesh 
  &  
   OCTO Mesh  4 Meta Server  Mesh 
 Mesh  
4.2
 OCTO Mesh 
  OCTO Mesh  
  OCTO Mesh  
 

<225



Base     tech@meituan.com

226> 2019 

XGBoost 

1. 
XGBoost "" XGBoost  Spark  XGBoost on Spark XGBoost on Spark   XGBoost  Spark 
 XGBoost Java  Spark Python   Java  XGBoost  
 XGBoost  XGBoost  Java Spark   Dmlc JNI  

// 41  double[] input = new double[]{1, 2, 5, 0, 0, 6.666666666666667, 31.14, 29.28, 0, 1.303333, 2.8555, 2.37, 701, 463, 3.989, 3.85, 14400.5, 15.79, 11.45, 0.915, 7.05, 5.5, 0.023333, 0.0365, 0.0275, 0.123333, 0.4645, 0.12, 15.082, 14.48, 0, 31.8425, 29.1, 7.7325, 3, 5.88, 1.08, 0, 0, 0, 32]; //  float[]

<227
float[] testInput = new float[input.length]; for(int i = 0, total = input.length; i < total; i++){
testInput[i] = new Double(input[i]).floatValue(); } //  Booster booster = XGBoost.loadModel("${model}"); //  DMatrix41  DMatrix testMat = new DMatrix(testInput, 1, 41); //  float[][] predicts = booster.predict(testMat);
             333.67892            328.1694030761719

2. 
   6.666666666666667 
 Debug  

228> 2019 
XGBoost on Spark  XGBoostClassifier  XGBoostRegressor   API   API  JNI    
 Python   XGBoostClassifier  XGBoostRegressor  
 XGBoost on Spark   NaN-10  0   
XGBoost4j 
XGBoost4j  DMatrix  0.0f  
/** * create DMatrix from dense matrix * * @param data data values * @param nrow number of rows * @param ncol number of columns * @throws XGBoostError native error */
public DMatrix(float[] data, int nrow, int ncol) throws XGBoostError { long[] out = new long[1];
//0.0f  missing  XGBoostJNI.checkCall(XGBoostJNI.XGDMatrixCreateFromMat(data, nrow, ncol, 0.0f, out));
handle = out[0]; }
XGBoost on Spark 
 xgboost on Spark  NaN 

<229
/** * @return A tuple of the booster and the metrics used to build
training summary */
@throws(classOf[XGBoostError]) def trainDistributed(
trainingDataIn: RDD[XGBLabeledPoint], params: Map[String, Any], round: Int, nWorkers: Int, obj: ObjectiveTrait = null, eval: EvalTrait = null, useExternalMemory: Boolean = false,
//NaN  missing  missing: Float = Float.NaN,
hasGroup: Boolean = false): (Booster, Map[String, Array[Float]]) = {
//... }
 Java  DMatrix  0 
 XGBoost on Spark  NaN 
 Java  XGBoost on Spark 


       Java            NaN     
328.1694
// 41  double[] input = new double[]{1, 2, 5, 0, 0, 6.666666666666667, 31.14, 29.28, 0, 1.303333, 2.8555, 2.37, 701, 463, 3.989, 3.85, 14400.5, 15.79, 11.45, 0.915, 7.05, 5.5, 0.023333, 0.0365, 0.0275, 0.123333, 0.4645, 0.12, 15.082, 14.48, 0, 31.8425, 29.1, 7.7325, 3, 5.88, 1.08, 0, 0, 0, 32]; float[] testInput = new float[input.length]; for(int i = 0, total = input.length; i < total; i++){
testInput[i] = new Double(input[i]).floatValue(); }

230> 2019 
Booster booster = XGBoost.loadModel("${model}"); // 41  DMatrix testMat = new DMatrix(testInput, 1, 41, Float.NaN); float[][] predicts = booster.predict(testMat);
3. XGBoost on Spark 
 Spark ML SparseVector
 SparseVector  DenseVector  
 DenseVector  Vector  Vector  
  SparseVector  0   SparseVector  0  0 
 0      0 SparseVector 
SparseVector 

<231
SparseVector  0  0 
 0  Spark ML  VectorAs-
sembler  0 SparseVector 

private[feature] def assemble(vv: Any*): Vector = { val indices = ArrayBuilder.make[Int] val values = ArrayBuilder.make[Double] var cur = 0 vv.foreach {
case v: Double =>
//0  if (v != 0.0) {
indices += cur values += v } cur += 1 case vec: Vector => vec.foreachActive { case (i, v) =>
//0  if (v != 0.0) {
indices += cur + i values += v } } cur += vec.size case null => throw new SparkException("Values to assemble cannot be null.") case o => throw new SparkException(s"$o of type ${o.getClass.getName} is not supported.") } Vectors.sparse(cur, indices.result(), values.result()).compressed }
                     SparseVector 
 Spark ML  XGBoost on
Spark XGBoost on Spark  Sparse Vector  0 


232> 2019 
val instances: RDD[XGBLabeledPoint] = dataset.select( col($(featuresCol)), col($(labelCol)).cast(FloatType), baseMargin.cast(FloatType), weight.cast(FloatType)
).rdd.map { case Row(features: Vector, label: Float, baseMargin: Float, weight: Float) =>
val (indices, values) = features match {
//SparseVector  0  XGBoost  case v: SparseVector => (v.indices, v.values.map(_.toFloat))
case v: DenseVector => (null, v.values.map(_.toFloat)) } XGBLabeledPoint(label, indices, values, baseMargin = baseMargin, weight = weight) }
XGBoost on Spark  SparseVector  0 

   Spark ML   Vector                
Vector             SparseVector   DenseVector  
    Vector       Spark              
SparseVector  DenseVector
 Sparse  Dense 

/** * Returns a vector in either dense or sparse format, whichever
uses less storage. */
@Since("2.0.0") def compressed: Vector = {
val nnz = numNonzeros // A dense vector needs 8 * size + 8 bytes, while a sparse vector needs 12 * nnz + 20 bytes. if (1.5 * (nnz + 1.0) < size) {
toSparse } else {
toDense } }

<233
 XGBoost on Spark  Float.NaN   DenseVector Float.NaN  SparseVector XGBoost on Spark   SparseVector  0  Float.NaN  0
 DenseVector XGBoost  Float.NaN SparseVector  XGBoost  Float.NaN  0
 Float.NaN  0  Float.NaN   XGBoost on Spark 0  
 Serving  SparseVector   Serving 
4. 
 XGBoost on Spark   XGBoost on Spark XGBoost on Spark 
val instances: RDD[XGBLabeledPoint] = dataset.select( col($(featuresCol)), col($(labelCol)).cast(FloatType), baseMargin.cast(FloatType), weight.cast(FloatType)
).rdd.map { case Row(features: Vector, label: Float, baseMargin: Float, weight: Float) =>
//  val values = features match {
//SparseVector  Dense case v: SparseVector => v.toArray.map(_.toFloat)
case v: DenseVector => v.values.map(_.toFloat) } XGBLabeledPoint(label, null, values, baseMargin = baseMargin,

234> 2019 
weight = weight) } /** * Converts a [[Vector]] to a data point with a dummy label. * * This is needed for constructing a [[ml.dmlc.xgboost4j.scala.
DMatrix]] * for prediction. */
def asXGB: XGBLabeledPoint = v match { case v: DenseVector => XGBLabeledPoint(0.0f, null, v.values.map(_.toFloat)) case v: SparseVector =>
//SparseVector  Dense XGBLabeledPoint(0.0f, null, v.toArray.map(_.toFloat))
}


 XGBoost 




   AB     /  /   / tech@ meituan.com

<235
 Spring Boot "" 


 MDP   Spring Boot               Swap           4G       7G     JVM     "-XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -XX:+AlwaysPreTouch -XX:ReservedCodeCacheSize=128m -XX:InitialCodeCacheSize=128m, -Xss512k -Xmx4g -Xms4g,-XX:+UseG1GC -XX:G1HeapRegionSize=4M" 
top 

236> 2019 

1.  Java Code   unsafe.allocateMemory  DirectByteBuffer  
 -XX:NativeMemoryTracking=detailJVM   jcmd pid VM.native_memory detail 
jcmd 

<237  committed  jcmd  Code  unsafe.allocateMemory  DirectByteBuffer   Native CodeC   Native Code   pmap  64M   jcmd  64M 
pmap 

238> 2019 
2. 
 Native Code  Java  
 gperftools  gperftools  gperftoolsgperftools 
gperftools 
 malloc  3G   700M-800M Native Code  malloc   mmap/brk gperftools  glibc
 strace      gperftools                 "strace -f -e"brk,mmap,munmap"-p pid" OS  strace  :
strace 

<239  GDB  dump   strace   gdp -pid pid  GDB  dump memory mem.bin startAddress endAddressdump  startAddress  endAddress  / proc/pid/smaps  strings mem.bin  dump 
gperftools 
 JAR  JAR   strace   strace
 strace   strace  64M  
strace 
 mmap  pmap 

240> 2019 
strace  pmap 
 jstack   strace  ID jstack pid   10  16 
strace 
MCC Reflec-

<241 tions  Spring Boot  JAR JAR  Inflater  Btrace 
btrace 
 MCC  
3. 
       64MJAR    gperftools  700M 
 malloc 

242> 2019 
            Spring Boot Loader         Spring Boot  Java JDK  InflaterInputStream  Inflater  Inflater  JAR  ZipInflaterInputStream  Inflater  Spring Boot  bug Inflater   finalize  Spring Boot  GC 
 jmap  Inflater   GC  finalize Inflater   Spring Boot Loader  Inflater finalize   finalize  Inflater  C   malloc end  free 
 free  Spring Boot  InflaterInputStream  Java JDK  
 gperftools  Spring Boot   3G  700M  GC  
glibc 2.12  gperftools  2.5G  smaps  Native Stack 

<243
gperftools 
 glibc 64M glibc  2.11 64  64M 
glib 
 MALLOC_ARENA_MAX   tcmallocgperftools 
  gcc zjbmalloc.c -fPIC -shared -o zjbmalloc.so  export LD_PRELOAD=zjbmalloc.so  glibc  Demo 

244> 2019 

#include<sys/mman.h>

#include<stdlib.h>

#include<string.h>

#include<stdio.h>

//  64 sizeof(size_t)  sizeof(long)

void* malloc ( size_t size )

{

long* ptr = mmap( 0, size + sizeof(long), PROT_READ | PROT_WRITE,

MAP_PRIVATE | MAP_

ANONYMOUS, 0, 0 );

if (ptr == MAP_FAILED) {

return NULL;

}

*ptr = size;

// First 8 bytes contain length.

return (void*)(&ptr[1]);

// Memory that is after length

variable

}

void *calloc(size_t n, size_t size) {

void* ptr = malloc(n * size);

if (ptr == NULL) {

return NULL;

}

memset(ptr, 0, n * size);

return ptr;

}

void *realloc(void *ptr, size_t size)

{

if (size == 0) {

free(ptr);

return NULL;

}

if (ptr == NULL) {

return malloc(size);

}

long *plen = (long*)ptr;

plen--;

// Reach top of memory

long len = *plen;

if (size <= len) {

return ptr;

}

void* rptr = malloc(size);

if (rptr == NULL) {

free(ptr);

return NULL;

}

rptr = memcpy(rptr, ptr, len);

free(ptr);

return rptr;

<245

}

void free (void* ptr )

{

if (ptr == NULL) {

return;

}

long *plen = (long*)ptr;

plen--;

// Reach top of memory

long len = *plen;

// Read length

munmap((void*)plen, len + sizeof(long));

}

  700M-800M gperftools  700M-800M 



 malloc  800M 1.7G   mmap mmap   536k  512k * 4kpagesize= 2G   1.7G   mmap    Page

246> 2019 


MCC  JAR Spring Boot   GC Spring Boot  finalize  glibc  ""  MCC  JAR  Spring Boot     2.0.5.RELEASE       ZipInflaterInputStream  GC Spring Boot  

1. GNU C Library (glibc) 2. Native Memory Tracking 3. Spring Boot 4. gperftools 5. Btrace

2015  C 

<247



   AB  1 AB  A  B   Google  2000  AB   2011 Google  7,000  AB ""  AB 
 1 AB 

248> 2019 
  AB   AB    
Wedge 


Wedge 
         

Overlapping Experiment Infrastructure: More, Better, Faster ExperimentationGoogle   LBS  

 Google  

<249
  Overlapping Layer "" "" "" H1  H2  H1  H2
  Non-overlapping Layer "" "" CTR""  V1  V2 V1  V2
 "" 
       
  

 2 
 Web  UI 
      SDK 

250> 2019 
 2

1.  
 3   App App 
  Scene
  Layer matching 
 Matching Layer  Layer 

<251  Layer    Layer  Scene   A   3  Layer_3  Layer_4   Layer Layer    Exp
 3
  4    Layer
 4  Layer_1 10   334    Layer 

252> 2019   4  Layer_2  Layer_3 4   Exp_6  Exp_7
 4
2. 
  Layer 


<253  Hash  Hash 
 Hash   Hash  uuid dpid   Hash Hash  +scene_id   Hash Hash  +scene_id+layer_id+layer_name   Hash  Bucket 100
 Bucket  Bucket   Bucket Bucket  1%   5 50%  Exp_1Exp_2  20%  10%  
 5
 6    Hash    Hash  Hash  hashNum
 50  99 V_Exp_1V_Exp_2     50  99 Hash  Hash  hashNum Exp_1Exp_2  

254> 2019 
 6
  7     
 7

<255
  >  > 
3. 
                               table 

1.  
2.  



 8

256> 2019 
AB 
 CTR CTR PV RPS 
PVSPVServer PVCPVClient PV CPV  requestId   requestId  join  request  Durid 
 join  OLAP  Druid Druid   OLAP Druid    

 Wedge 

<257
     
 . 

 . 
  Java  C++ 
tech@meituan.com 

258> 2019 
  


      Bug  ""  
   
 
1.  
2.  

<259

 Generalized Alarms  1 
1
 

 2  
2

260> 2019 

"Clustering Intrusion Detection Alarms to Support Root Cause Analysis [KLAUS JULISCH, 2002]"  
server_room_a-biz_tag-online02 Thrift get deal ProductType deal error. server_room_b-biz_tag-offline01 Pigeon query deal info error. server_room_a-biz_tag-offline01 Http query deal info error. server_room_a-biz_tag-online01 Thrift query deal info error. server_room_b-biz_tag-offline02 Thrift get deal ProductType deal error.
"  " "server_room_a   " "server_room_b  RPC " 
 
DAG 3 
 3
  Attribute
 Ai 

<261
 Domain Ai  Dom(Ai)   Generalization Hierarchy Ai 
 Gi   Dissimilarity d(a1, a2) a1a2 
 d(a1, a2)  a1  a2  
 d(a1, a2) x1x2   Ai  x1x2  Gi   p  x1x2  d(x1, x2) := min{d(x1, p) + d(x2, p) | p  Gi, x1 p, x2 p} 3 d("Thrift", "Pigeon") = d("RPC","Thrift") + d("RPC","Pigeon") = 1 + 1 = 2
 a1a2
 1
a1 = ("server_room_b-biz_tag-offline02","Thrift"), a2 = ("server_room_a-biz_tag-online01","Pigeon"),  d(a1, a2) = d("server_room_ b-biz_tag-offline02","server_room_a-biz_tag-online01") + d(("Thrift", "Pigeon") = d("server_room_b-biz_tag-offline02","") + d("server_ room_a-biz_tag-online01","   ") + d("RPC","Thrift") + d("RPC", "Pigeon") = 2 + 2 + 1 + 1 = 6
 C g  C   a  C, a g      {"dx-trip-package-api02 Thrift get deal list error.","dx-trippackage-api01 Thrift get deal list error."} "dx  thrift   ""  "

262> 2019 
 
 2
H©  g g  C  ""(Cover)
 L min_ size Gi(i = 1, 2, 3......n)  Ai   L  C |C| >= min_size H© min_size   min_size  L   min_size = 1  L 
 NP  |C| >= min_size H© 

1.  Gi  
2.  L  Ai L   Ai  Gi  Ai 
3.  2  min_size  
4.  3 

<263



 Lmin_size G1,......,Gn



T := L;

//  T

for all alarms a in T do

a[count] := 1; // "count"  a 

while a  T : a[count] < min_size do {

 Ai;

for all alarms a in T do

a[Ai] := parent of a[Ai] in Gi;

while identical alarms a, a' exist do

Set a[count] := a[count] + a'[count];

delete a' from T;

}

 7  :

 Ai  Fi
fi(v) := SELECT sum(count) FROM T WHERE Ai = v  Fi := max{fi(v) | v  Dom(Ai)}  Fi  Ai

//  Ai  v 

 a  a[count]>= min_size  Ai ,  Fi >= fi(a[Ai]) >= min_size Ai  Fi  min_size a[count]  min_size Fi   Ai 
 min_size  min_size  
 ms0 (0 <  < 1) min_size  ms0ms0 * (1 - )ms0 * (1 + )   -  ms1 = ms0 * (1 - ) 
- 

264> 2019 


1. 
 Case  ID ID 
 Case  ID  
  5 
2. 
1              "code=......,message=......"   Case 

<265  "" 2  4 
 4

266> 2019  3min_size  min_size
= 1/5 *   min_size = 1/5 *   0.05
4  min_size   20   count  min_size  3.    
 5

<267
 6
 7
 8
"" 

 C  API 
1. 


268> 2019       939   9 
 9

<269

 1 

ID

Server Room

Error EnvironSource ment

Position  


1   Prod

com.*.*.*.CommonProductQueryClient

Summary   Count
 com.netflix.hystrix. exception.HystrixTimeoutException: commonQueryClient. 249 getProductType execution timeout after waiting for 150ms.

2   Prod

java.lang.IllegalArgu-

com.*.*.*.PluginReg- mentException: 

240

istry.lambda

 : 



3   Prod

com.*.*.*.TrProductQueryClient

com.netflix.hystrix. exception.HystrixTimeoutException: TrQueryClient.listTr- 145 ByDids2C execution timeout after waiting for 1000ms.



(  /

4 

Prod

 / 

 )

com.*.*.*.RemoteDealServiceImpl

com.netflix.hystrix.

exception.Hystrix-

TimeoutException:

ScenicDealList.

89

listDealsByScenic

execution timeout af-

ter waiting for 300ms.

5   Prod

com.*.*.*.CommonProductQueryClient

com.netflix.hystrix. exception.HystrixTimeoutException: commonQueryClient. 29 listTrByDids2C execution timeout after waiting for 1000ms.

6   Prod

com.*.*.*.ActivityQueryClientImpl

com.netflix.hystrix. exception.HystrixTimeoutException: commonQueryClient. 21 getBusinessLicense execution timeout after waiting for 100ms.

270> 2019 

Position 

Server Error Environ-

ID



Room Source ment



7   prod

com.*.*.*.CommonProductQueryClient



(  /

8 

Prod

 / 

 )

com.*.*.*.RemoteDealServiceImpl

9   Prod 10   Prod

com.*.*.*.TrProductQueryClient com.*.*.*.TrProductQueryClient

Summary   Count
 com.netflix.hystrix. exception.HystrixTimeoutException: commonQueryClient. 21 getBusinessLicense execution timeout after waiting for 100ms.
com.netflix.hystrix. exception.HystrixTimeoutException: HotelDealList. 17 hotelShelf execution timeout after waiting for 500ms.
Caused by: java.lang. 16
InterruptedException
Caused by: java.lang. 13
InterruptedException

 Count  

2. 
 Staging  A/B  

 Staging   A/B   527 

 10 

<271
 10

272> 2019 

 2 

Position 

Server Error Envi-

Summary 

ID



Count

Room Source ronment





com.*.*.*.Activi- [hystrix]  , circuit

1   Staging

291

tyQueryClientImpl short is open

com.*.*.*.AbEx- [hystrix] tripExperiment

2  A/B  Staging

105

perimentClient error, circuit short is open

3  

com.netflix.hystrix.ex-

ception.HystrixTimeout-

com.*.*.*.Cache- Exception: c-cache-rpc.

Staging

15

ClientFacade

common_deal_base.rpc

execution timeout after

waiting for 1000ms.

com.*.*.*.que4   Staging
ryDealModel

Caused by: com.meituan. service.mobile.mtthrift. netty.exception.Request- 14 TimeoutException: request timeout

com.netflix.hystrix.

exception.HystrixTimeout-

com.*.*.*.Com-

Exception: commonQuery-

5   Staging monProductQue-

9

Client.getBusinessLicense

ryClient

execution timeout after

waiting for 100ms.

com.*.*.*.getOr- java.lang.IllegalArgument-

6   Staging

7

derForm

Exception: 

com.*.*.*.Pre7   Staging
SaleChatClient

com.netflix.hystrix.exception.HystrixTimeoutException: CustomerService.Pre- 7 SaleChat execution timeout after waiting for 50ms.

8  

Staging

Caused by: java.net.Sockcom.*.*.*.Spring-
etTimeoutException: Read 7 CacheManager
timed out

com.*.*.*.que9   Staging
ryDetailUrlVO

java.lang.IllegalArgument2
Exception: 

com.*.*.*.que10   Staging
ryDetailUrlVO

java.lang.IllegalArgument1
Exception: 

 

<273
3. 
 Staging  
 Staging    2165  11 
 11

274> 2019 

 3 

ID

Server Room

Error Source

Environment

1  Squirrel Staging

Position  
com.*.*.*.cache

Summary   
 Timeout

Count 491

2  Cellar Staging com.*.*.*.cache

Timeout

285

3  Squirrel Staging com.*.*.*.TdcServiceImpl

Other Exception 149

4  

Staging com.*.*.*.cache

Timeout

147

5  Cellar Staging com.*.*.*.TdcServiceImpl

Other Exception 143

6  Squirrel Staging com.*.*.*.PoiManagerImpl 

112

com.*.*.*.CommonPro7   Staging
ductQueryClient

Other Exception 89

8  

Staging com.*.*.*.TrDealProcessor Other Exception 83

9  

Staging com.*.*.*.poi.PoiInfoImpl

Other Exception 82

10   Staging com.*.*.*.client

Timeout

74

Squirrel  Cellar    
   Other Exception
 
 


 

<275
1.   
2.   K-Means
3.  

1. Julisch, Klaus."Clustering intrusion detection alarms to support root cause analysis."ACM transactions on information and system security (TISSEC) 6.4 (2003): 443-471.
2. https://en.wikipedia.org/wiki/Cluster_analysis

2017  2017 

276> 2019 



  2018   
    
  1 
 1

<277   2        
 2
Quake   
  
   Mock 
  
  /   

278> 2019  
  
  


 3
 3  /  /    
 /   Mock   Mock   Mafka/Cellar/Squirrel/Zebra 

<279
 
  ""
  / 
 
 
     
    SSO    
    /  /  
   Quake  Quake


280> 2019 

 4
 
 Mock   4    
 5 Mock 

<281  Mock  Mock  Mock  4  C SDK  Mock  5  Mock  JVM-Sandbox  AOP  Mock  Mock                                Mock  Mock  0  Mock  Mockserver   SDK  Mock  Mock   Mock  Mock 

 6
   Java   Java  Java 

282> 2019   RPC  
                              Quake   6   Quake   Quake 
 Quake 

 7
     

<283     Zebra   Cellar/Squirrel   Mafka    Mock    MTrace  4 Mock   Mock   MTrace 

 8MTrace 
  Mock 

284> 2019   Mock 
 9 Mock 
  
 10
  
 /  

<285 
 QPS  

  11  QPS    QPS   
 11
 11    /   

286> 2019 


 / 
 

    Mock ""

<287

 "" 7  

Quake 
  Quake   Quake """"

288> 2019 

  
 


 

<289

   

290> 2019 

  ""   

[1] Quake [2]  JVM-Sandbox [3] Dubbo  [4] Java 

2013 

<291



    Tcl      John Ousterhout   A Philosophy of Software Design[1] IT  """" "" """ """ A Philosophy of Software Design 
       "     "                  John Ousterhout "" 

  (  ) [2]  
John Ousterhout  

292> 2019 
 cp  tp  C  (  tp 
 cp 
     Unknown Unknowns
 (Obscurity)  

    
     
 

<293  
   Unknown Unknowns

4.1
 Bug   
 
  bug "" 

294> 2019 
 10-15%   
4.2
        "" ""  

5.1
   TCP/IP 

<295
TCP/IP   IP  
5.2
  Thrift  Thrift  (   (  XML   (  )  
 

296> 2019 
5.3
  
   

  
6.1
 (Deep Module)  

<297
Unix  I/O  Open   
int open(const char* path, int flags, mode_t permissions);
 (Shallow Module)   Java I/O  I/O  FileInputStreamBufferedInputStreamObjectInputStream  BufferedInputStream I/O   I/O  I/O  
FileInputStream fileStream = new FileInputStream(fileName); BufferedInputStream bufferedStream = new BufferedInputStream(fileStream); ObjectInputStream objectStream = new ObjectInputStream(bufferedStream);
   
6.2
   
 

298> 2019 

void backspace(Cursor cursor); void delete(Cursor cursor); void deleteSelection(Selection selection); //  void delete(Position start, Position end);
 
  
  
  
6.3
  "" "" 
   B+    SQL  

<299
  [3]  
6.4
"" 
       
 

  (Unkown Unkowns)   
  
7.1
 """"" """

300> 2019 
   "" ""
7.2
 What  Why  (How)
     
   
   
   
 

<301
 
  
7.3
     

John Ousterhout  25  3    
   

 John Ousterhout. A Philosophy of Software Design. Yaknyam Press, 2018.  · .  .  , 2016.  Martin Fowler. Refactoring: Improving the Design of Existing Code (2nd Edition) .
Addison-Wesley Signature Series, 2018.

302> 2019 



 /   ,   tech@meituan.com

