Exploiting Kernel Races Through
Taming Thread Interleaving
Yoochan Lee, Byoungyoung Lee, Chanwoo Min Seoul National University, Virginia Tech
#BHUSA @BLACKHATEVENTS

Summary

· Background on races

· Classification on races · Unexploitable races

· New technique turning unexploitable races to exploitable races
#BHUSA @BLACKHATEVENTS

Race condition is an increasing attack vector

15 bugs
OOB

30 bugs
UAF

7 bugs
Race

143 bugs 111 bugs

OOB

UAF

67 bugs
Uninit

81 bugs
Race

104 bugs
UAF

59 bugs
OOB

# of fixed bugs that Syzkaller found in 2017

# of fixed bugs that Syzkaller found in 2018

# of fixed bugs that Syzkaller found in 2019

· Razzer, IEEE S&P 2019, found more than 30 race bugs. · KCSAN, developed by Google 2019, found more than 300 race bugs.
3

#BHUSA @BLACKHATEVENTS

Background : Race condition

current execution

Core 1
A

Pair of race instruction

A

B

Instructions that access the same memory

Core 2

Result can be a

value stored in memory

or

B

a value

read by read instruction

Access Order

A >> B è Result X

B >> A è Result Y

· Accessing the same memory location from two processors

è Execution results are different depending on the access order.
4

#BHUSA @BLACKHATEVENTS

Background : Race Condition Vulnerability

Race Condition Vulnerability

=

Race Condition

+ Memory Corruption

Race instruction pair A
Race instruction pair B
. . .

Overflow
Use-After-Free
. . .

#BHUSA @BLACKHATEVENTS
5

Background : to trigger Race Condition Vulnerability

if

ABC

, then memory corruption occurs.

Brute forcing :
Try until success
6

#BHUSA @BLACKHATEVENTS

Background : Exploitability of Race Condition Vulnerability

Exploitable Races?

A very specific

Availability of

= memory access order + Memory Corruption

(e.g., if A >> B >> C , then)

#BHUSA @BLACKHATEVENTS
7

Classification of Race Condition Vulnerability

Race Condition Vulnerability

Single Variable Race Condition

Race instruction pair 1 for M1

Race instruction pair 2 for M1

...

Single variable

Multi Variable Race Condition

Race instruction pair 1 for M1

Race instruction pair 2 for M2

...

Multi variable

#BHUSA @BLACKHATEVENTS
8

Single-variable Race Condition

Core 1 Pair
A
Time Window
C
Pair

Core 2

inet->hdrincl is 1

B
inet->hdrincl is 0

Control Flow Dependency Data Flow Dependency

raw_sendmsg() {
...
A if ( ! inet->hdrincl ) {
// initialize rfv variable
rfv.msg = msg; ...
}
C if ( ! inet->hdrincl ) {
memcpy(to, rfv->hdr.c, ... );
} ...
}

do_ip_setsockopt() {
...
B inet->hdrincl = 0;
... }

Case study : CVE-2017-17712

if A >> B >> C , then uninitialized buffer use occurs.

#BHUSA @BLACKHATEVENTS
9

Exploitability of Single-variable Race

Order violation

Core 1
A

Time Window

C
Order violation

Core 2
B

· Brute-forcing would somehow trigger the race

è if B can be executed within the time window

· The smaller the time window is, the lower the probability of successful races.
#BHUSA @BLACKHATEVENTS
10

Multi-variable Race Condition

Core 1
A

Core 2

Time Window
x

B

Time

Window

C

y

D

Control flow Dependency Data flow Dependency

Pair of race instruction

A

B

Instructions that access the M1

Pair of race instruction

CD

Instructions that access the M2

if A >> B && C >> D ,
then memory corruption occurs.

#BHUSA @BLACKHATEVENTS
11

Multi-variable Race Condition
Multi-variable Race Condition

Core 1 Inst pair
to access M1 A

Core 2

B

Tx

Ty

C

D
Inst pair to access M2
Tx > Ty Inclusive Multi-variable Race

Core 1

Core 2

Inst pair to access M1
A
Tx
D

B
Ty

Inst pair

C

to access M2

Tx  Ty Non-inclusive Multi-variable Race

#BHUSA @BLACKHATEVENTS
12

Exploitability of Inclusive Multi-variable Race

Race Pair

Core 1
A

Tx

Race Pair

D

Core 2
B
Ty
C

· Brute-force somehow works. · The more similar the two time windows are, the lower the probability that a race will occur.

#BHUSA @BLACKHATEVENTS
13

Problem : Exploitability of Non-inclusive Race

binder_alloc_mmap_handler() {
// initialize vma
A alloc->vma = vma;
Tx = 18 cycles
D alloc->vma_vm_mm =
vma->vm_mm;

binder_alloc_new_buf_locked() {
B if (alloc->vma == NULL) return ERR;
Ty = 2250 cycles
C mmget_not_zero(alloc->vma_vm_mm));

} }

Case study : Patch #987393

if A >> B && C >> D , then uninitialized buffer use occurs in C .

Core 1
A
Tx
D
Even if, A >> B is succeed, C >> D will be failed

Core 2
B
Ty
C

· Brute-force never works.

· impossible to execute with the order of A >> B && C >> D .
14

#BHUSA @BLACKHATEVENTS

Problem : Exploitability of Non-inclusive Race

Non-inclusive race vulnerabilities found in linux kernel

Tx

CVE-2017-15265

35

CVE-2019-1999

150

CVE-2019-2025

50

CVE-2019-6974

18

#1035566

1,153

#987393

18

#759959

120

.

.

.

Ty 450 1,800 600 1,210 13,121 2,250 730

Core 1
A
Tx
D
Even if, A >> B is succeed, C >> D will be failed

Core 2
B
Ty
C

· Brute-force never works.

· impossible to execute with the order of A >> B && C >> D .
15

#BHUSA @BLACKHATEVENTS

Previous method : Using Different Core Latency
Execution Order : A >> B & C >> D
race_function1():

Core 1
1.6 Ghz

A

D

race_function2():

B

C

Core 2

2.5 Ghz

· e.g., Qualcomm Snapdragon 845 4x 2.5GHz, 4x 1.6GHz
16

#BHUSA @BLACKHATEVENTS

Previous method : Using Different Core Latency
Execution Order : A >> B & C >> D
race_function1():

A

D

Core 1

1.6 Ghz

ction2():

B

C

Core 2

2.5 Ghz

· e.g., Qualcomm Snapdragon 845 4x 2.5GHz, 4x 1.6GHz
17

#BHUSA @BLACKHATEVENTS

Limitations of Use Different Core Latency

CPU

· Must use the CPU that latency between the cores are different. · Not applicable to vulnerabilities with large time window differences

CPU dependency

#BHUSA @BLACKHATEVENTS
18

Previous Approach : Using scheduler (CONFIG_PREEMPT)
Execution Order : A >> B & C >> D

Core 0
Core 1
Core 2 current execution

Jann Horn, Linux Security Summit EU 2019, "Exploiting Race Conditions Using the Scheduler"
è sched_setaffinity()

Wait queue :
19

#BHUSA @BLACKHATEVENTS

Previous Approach : Using scheduler (CONFIG_PREEMPT)
Execution Order : A

sched_setaffinity(Core 1, self):

R

Core 0

Hey, you need to

race_function1():

reschedule

A

D

Core 1
race_function2():

B

C

Core 2

current execution

Wait queue :
20

#BHUSA @BLACKHATEVENTS

Previous Approach : Using scheduler (CONFIG_PREEMPT)
Execution Order : A >> B & C

ction2():
B

Core 0
sched_setaffinity(Core 1, self):
R Core 1
C Core 2

current execution

race_function1():

Wait queue :

D

21

#BHUSA @BLACKHATEVENTS

Previous Approach : Using scheduler (CONFIG_PREEMPT)
Execution Order : A >> B & C >> D

Core 0

race_function1():

A

D

Core 1

Core 2
current execution

Wait queue :
22

#BHUSA @BLACKHATEVENTS

Limitation of Using scheduler
· Can be used when COFIG_PREEMPT option is applied. · Linux uses CONFIG_PREEMPT_VOLUTARY option by default. Configuration dependency
#BHUSA @BLACKHATEVENTS
23

Each of methods has obvious limitations

CPU

CPU dependency

Configuration dependency

· All previous methods are hard to be used in general. · We need a new method that extends the time window.
24

#BHUSA @BLACKHATEVENTS

How to extend the time window?

A

D

Core 1

Core 1

1. Stop the core

2. Degrade the performance
#BHUSA @BLACKHATEVENTS
25

ExpRace

Slow Performance :
A

Fast
Interrupt handler! Interrupt handler! Interrupt handler!
D

Core 1

Attacker

Bullets
· Inter-processor interrupt · Hardware Interrupt

· The key idea of ExpRace is to keep raising interrupts to indirectly alter kernel thread's
interleaving.

#BHUSA @BLACKHATEVENTS
26

ExpRace : How to send IPI & IRQ with user priv

Attacker (User Priv)
Attacker (User Priv)

user_function() {
syscall(); }
User mode

syscall() {
send_IPI(); }
Kernel mode

Send IPI to core1

Core 1

user_function() {
syscall(); }
User mode

syscall() {
send_REQ(); }
Kernel mode

Request to device

Send IRQ to core1

Hardware device

Core 1

#BHUSA @BLACKHATEVENTS
27

ExpRace : TLB Shootdown

~

~

~

0xABC0

0xABD0

0xABE0

cache

munmap(0xABD0)

Core 1

IPI Flush 0xABD0

~

~

~

0xABC0

0xABD0

0xABE0

cache

IPI_ha?ndler()

Core 2

· Modern OSs implement a TLB shootdown mechanism to ensure that TLB entries are
synchronized across different cores.

· Syscalls that either modify the permission of the page (e.g., mprotect()) or unmap (e.g.,
munmap()) the page use IPI for TLB shootdown.

#BHUSA @BLACKHATEVENTS
28

ExpRace : IPI Environment setting

mm 

mm 

mm 

Process C (Core 0)

Process A (Core 1)
A

IPI_send (core 1 and core 2)
Interrupt Tx +   handler

Process B (Core 2)

B

Interrupt handler



Ty + 

D

C
If 3 processes have same mm

29

Process C Process A Process B

(Core 0)

(Core 1)

(Core 2)

A
B
IPI_send (core 1)

Tx + 



Interrupt handler

Ty

C
D
If process A and C have same mm, and B have different mm
#BHUSA @BLACKHATEVENTS

ExpRace : Hardware Interrupt Environment Setting

1. Check irq's core affinity.
(In our environment, ethernet device (IRQ 122) have affinity to core 11)

Process C (Core 0) 1. connect()

2. req

4. IRQ

Process A Process B
(Core 11) (Core 2)
A B

3. res Ethernet

D

device

Tx +   ISR

2. Pin the thread to corresponding core using sched_setaffinity().

C

D

#BHUSA @BLACKHATEVENTS
30

ExpRace : How many cycles are extended?

Core 1
A

1,500 ~ 20,000 cycles

IPI

handler

Core 2
B
Ty

Core 1
A

About

ISR

15,000 cycles handler

Core 2
B
Ty

C D
TLB Shootdown
31

C D
Hardware Interrupt

#BHUSA @BLACKHATEVENTS

ExpRace : Advanced Technique

mm 

mm 

Process C Process A Process D

(Core 0)

(Core 1)

(Core 3)

A

IPI_send (core 1)
Tx + 

Interrupt



Handler +

ISR

1. connect() IRQ
Ethernet device

Process B (Core 2)
B
Ty

C

D

· IPI and IRQ can be used simultaneously.

· The time window is extended up to 200,000 cycles
32

#BHUSA @BLACKHATEVENTS

Case Study : CVE-2017-15265

snd_seq_create_port()

snd_seq_delete_port()

{

{

...

list_for_each_entry( ... p->list)

port = kzalloc();

{

list_add_tail(&port->list, &p->list);

A

if (p->addr.port == port) {

...

Tx = 110 cycles

z

strlcpy(port->name, info->name,

D

sizeof(port->name));

found = p; ... } } ...

B
Ty = 450 cycles

kfree(found);

C

}

}

Problems to exploit
z 1. Non-inclusive Multi-variable Race
2. No time to reallocate

if A >> B && C >> D , then Use-After-Free Write occurs.
33

#BHUSA @BLACKHATEVENTS

ExpRace can solve two problems at once

snd_seq_create_port()

{

...

port = kzalloc();

list_add_tail(&port->list, &p->list);

A

Interrupt Handler
Tx' = 110 + 15000 cycles

strlcpy(port->name, info->name,

D

sizeof(port->name));

}

snd_seq_delete_port() {

list_for_each_entry( ... p->list)

{

if (p->addr.port == port) {

found = p;

B

...

}

}

Ty = 450 cycles

...

kfree(found);

C

}

syscall_for_reallocte() {
kmalloc(); }

It takes about 3000 cycles

if A >> B && C >> D , then Use-After-Free Write occurs.
34

#BHUSA @BLACKHATEVENTS

Brief introduction about memory corruption exploit

· Spray struct file pointer using SCM_RIGHT · Partially overwrite the pointer in reallocated structure for
kernel address leak.
· Use iovec structure for arbitrary memory write and read.

1st Use-After-Free Write Leak : struct file pointer
2nd Use-After-Free Write AAR : file->f_cred pointer
3rd Use-After-Free Write AAW : f_cred -> uid = 0 We totally trigger the vulnerability 3 times

#BHUSA @BLACKHATEVENTS
35

DEMO
#BHUSA @BLACKHATEVENTS
36

Conclusion
· Introduced unexploitable race types. · ExpRace can turn unexploitable races into exploitable races.
#BHUSA @BLACKHATEVENTS
37

