Crashing Your Way to Medium-IL: Exploiting the PDB Parser for Privilege Escalation
Gal De Leon (@galdeleon) Palo Alto Networks
#BHUSA @BlackHatEvents

Who am I?
 Gal De Leon (@galdeleon)  Principal security researcher at Palo Alto Networks  Interested in fuzzing, vulnerabilities, exploits and mitigations  Microsoft MSRC MVSR 2018, 2019, 2020
 ~40 vulnerabilities
2

Agenda
 What are PDBs?  Finding vulnerabilities in PDB parser  Attack surfaces  Exploit & Demo
3

What are PDB Files?
 Store debugging info (symbols) about an executable  Function names, globals, type info ...  Created from source files during build  Used by debuggers
0:007> .reload /f notepad.exe 0:007> x notepad!* 00007ff7`9b4c4520 notepad!__scrt_uninitialize_thread_safe_statics (void) 00007ff7`9b4a86b0 notepad!ShowOpenSaveDialog (void) 00007ff7`9b4c09e8 notepad!StringLengthWorkerW (void) 00007ff7`9b4c38e0 notepad!initialize_printf_standard_rounding (void) 00007ff7`9b4a1640 notepad!`dynamic initializer for 'szFileName'' (void) ...
4

The PDB File Format
 Proprietary file format by Microsoft
 Binary  Multi Stream Format (MSF)
 Open sourced for non-MS compilers to produce PDBs  Parser implemented in Dbghelp.dll
 Shipped by default  API to debug a process, load PDBs, extract symbols data ...
5

Let's Fuzz PDB
6

Fuzzing Setup
 Corpus - ~5000 PDBs from several sources  Test Harness - A program that loads a PDB file and parse it
 Dbghelp!SymLoadModule
 WinAFL fuzzer
Repeat

Start

Corpus

Mutator

Run Harness

Crashes
7

8

What is the Attack Surface?
 Remote symbol servers  Attacker controls / MitM symbols server can serve arbitrary PDBs

0:007> .sympath srv*http://msdl.microsoft.com/download/symbols Symbol search path is: srv*http://msdl.microsoft.com/download/symbols Expanded Symbol search path is: srv*http://msdl.microsoft.com/download/symbols
0:007> .reload /f notepad.exe

Attacker (MitM)

Victim Debugger

Symbol Server
9

Report to Microsoft MSRC
 18-08-2020 - Initial report to Microsoft MSRC  15-09-2020 - Doesn't meet the bar for security servicing
 Attack surface is too complex
"... In this case, Microsoft has decided that it will not be fixing this vulnerability in the current version and we are closing this case.In order to exploit this an attacker would need to control the symbol server or MitM the connection. Then the victim would have to load a PDB from the server. At this time, you are able to blog about/discuss this case and/or present your findings publicly about the current version. ..."
11

Other Attack Surfaces
 Other components that use Dbghelp.dll to parse PDBs
 How about elevation of privileges?
 Text-search `Dbghelp.dll' in all binaries under C:\Windows
 Appverif.exe, appverifUI.dll, comsvcs.dll, devinv.dll, taskkill.exe ... faultrep.dll, wer.dll
 WER uses Dbghelp.dll!
 I already discovered ~15 vulnerabilities in WER... Check out my BlueHatIL talk
12

Windows Error Reporting Recap

 WER collects info regarding crashes / hangs and reports to Microsoft  Process crash -> WerFault.exe worker is launched

Process.exe

ALPC

Parent: Process.exe Child: WerFault.exe

WerFault.exe

svchost.exe
(WerSvc)
CreateProcessAsUser()

13

How Does WerFault.exe Use Dbghelp.dll?
 Parse the stacktrace of the crashing thread  Add stacktrace hash to error report
 Allows Microsoft to group crashes by stacktrace
long long UtilGetStackTrace(long ProcessId, long ThreadId) { /* ... */ HANDLE CrashingProc = OpenProcess( PROCESS_ALL_ACCESS, 0, ProcessId); SymInitialize(CrashingProc, NULL, fInvadeProcess=TRUE); /* ... */ for ( ... ) { StackWalk(); }
14

15

WerFault.exe Permissions
 Usually WerFault.exe runs with the same privileges of the crashing process  One exception: Low-IL crash -> Medium-IL WerFault.exe
16

Integrity Levels (IL)
 ILs restrict processes running under the same user account
 Low-IL is used for sandboxing
 E.g. iexplore renderers runs under Low-IL
 Browser exploit chains: renderer RCE -> sandbox escape/EoP
17

What's the Game Plan?

 Elevate privileges from Low-IL to Medium-IL

 From Low-integrity process:
 Write malformed PDB file to disk  Crash my own process (Low-IL)  WerFault.exe (Medium-IL) launches  WerFault.exe loads malformed PDB file
 Exploit PDB parsing bug for EoP

WriteFile

crash.pdb

LoadSymbol

PProrcoecsess.se.xeexe ((LLooww-) IL)
WerFault.exe (Medium-IL)

18

Load PDBs From Arbitrary Paths
 Cannot write to most paths as Low-IL
 C:\users\gdeleon\AppData\LocalLow directory (%AppData%\LocalLow)
 How to get WerFault.exe to load PDB from %AppData%\LocalLow?  PdbFilePath in PE / Executable header
 Run my own EXE, point PdbFilePath to %AppData%\LocalLow
struct CV_INFO_PDB20 {
CV_HEADER CvHeader; DWORD Signature; DWORD Age; BYTE PdbFilePath[]; };
19

(91c.1024): Access violation - code c0000005 (first chance) 6dd52abe mov eax,dword ptr [ebx+164h] ds:002b:08007e6e=???????? 0:000> k ChildEBP RetAddr 02b8a4ec 6dd4ac82 dbghelp!ModCache::pbSyms+0xe ... 02b8f7f0 0072ceaf faultrep!WerpInitiateCrashReporting+0x40f 02b8f838 007039cd WerFault!UserCrashMain+0x2b1 02b8f878 007419a0 WerFault!wmain+0x13e
20

Dbghelp.dll Bug
21

DbgHelp!SymCache::PsymForImodOff
int Index = ...; /* Read from PDB file */; /* Certain checks on Index */; Object* Obj = ObjectsArray[Index - 1]; Obj->VirtualFunctionCall();
22

DbgHelp!SymCache::PsymForImodOff
 The bug - Index is allowed to be equal to 0
 Type confusion
int Index = ...0; /* Read from PDB file */; /* Certain checks on Index */; Object* Obj = ObjectsArray[Index - 1]; Obj->VirtualFunctionCall();

-1

0

1

2

??

Obj0

Obj1

Obj2

23

What's on Index -1?
 ObjectsArray is allocated on the heap  There's a heap header prior to every heap allocation
 Metadata about the allocation

-1 Heap Header

0 Obj0

1 Obj1

2 Obj2

24

Heap Header Structure (32 bit)

 8 bytes header prior to every heap allocation
 Low DWORD part is confused with Object*

-2 Header High

-1 Header Low

0 Obj1

0:000> dt -t _HEAP_ENTRY +0x000 UnpackedEntry +0x000 Size +0x002 Flags +0x003 SmallTagIndex +0x004 PreviousSize +0x006 SegmentOffset +0x007 UnusedBytes

: _HEAP_UNPACKED_ENTRY : Uint2B : UChar : UChar : Uint2B : UChar : UChar

25

Heap Encoding
 `Security-cookie' to prevent heap overruns exploits
 Header XOR random key (_HEAP->Encoding)
 8-bytes key generated per heap at runtime (ntdll!RtlpCreateHeapEncoding)  Part of the key is always set zero!
 2 high bytes of the second dword  Remains cleartext (X ^ 0 = X)
0:000> dt -t _HEAP ntdll!_HEAP
+0x050 Encoding 0:000> dd 01360000+50 L2
01360050 18be3a5a 00006ab6
26

Is the Heap Header Value Predictable?

 Encoded header example: AAAAAAAA XXYYBBBB

 XXYYBBBB => Fake Object*

 MSB (XX) meaning is UnusedBytes

 Diff between malloc(size) and actual chunk size

 Remains cleartext (XX ^ 0)
 ObjectArray is a small allocation  12 bytes
 UnsuedBytes is predictable  0x18
 Fake Object* is a low usermode address

0:000> dt -t _HEAP_ENTRY +0x000 UnpackedEntry +0x000 Size +0x002 Flags +0x003 SmallTagIndex +0x004 PreviousSize +0x006 SegmentOffset +0x007 UnusedBytes

 0x18XXXXXX

: Uint2B : UChar : UChar : Uint2B : UChar : UChar

27

Heap Header 0x18XXXXXX

0 Obj0

1 Obj1

2 Obj2

Object Control this value
VPTR

int Index = 0; Object* Obj = ObjectsArray[0 - 1 = -1]; Obj->Func2();

Func1 ControFlutnhci2s value
...

MOV eax, [ecx] ; Obtain vptr CALL [eax + 4] ; Call vfunc

28

32Bit Crash? 32Bit WerFault!
 32bit process crash -> 32bit WerFault.exe
 Much easier to spray in 32bit  Allocators more predictable
29

Spray Primitive
 Goal: Spray WerFault.exe address space from crashing process (Low-IL)  Dbghelp!SymInitialize loads PDBs for all loaded module
 PDB #1 - Spray  PDB #2 - Trigger vulnerability
 How to spray from PDB #1?
 Very large PDB file  Entire PDB is mapped using kernel32!MapViewOfFile
 kernel32!MapViewOfFile is predictable (64k alignment)  Dbghelp doesn't unmap invalid PDBs
 When bug is triggered (PDB #2) sprayed memory (PDB #1) is in place
30

Process.exe ((CLroawsh-eILd))
WriteFile SymInitialize

WerFault.exe (Medium-IL)

Sprraayy..ppddbb Triiggggeerr.p.pddbb

WerFault.exe Address Space 0
Obj Spray

Trigger

Heap Header

Objs Array

ffffffff

0:000:x86> ub

dbghelp!ModCache::pbSyms+0xe9:

701e2f39 8b8354010000 mov

701e2f3f 8bb88c000000 mov

701e2f45 8b07

mov

701e2f47 8b7078

mov

701e2f4a 8bce

mov

701e2f4c ff1568243370 call

701e2f52 8bcf

mov

701e2f54 ffd6

call

0:000:x86> .frame 0

00 006fe2e0 701e2f56 0x0e0e0e0e

eax,dword ptr [ebx+154h] edi,dword ptr [eax+8Ch] eax,dword ptr [edi] esi,dword ptr [eax+78h] ecx,esi dword ptr [dbghelp!__guard_check_icall_fptr] ecx,edi esi

Where to Call to?
 Problem: CFG is enabled on WerFault.exe
 CFI mitigation to prevent ROP/code-reuse attacks  Can only call CFG valid call targets
 kernel32!LoadLibrary is a valid CFG target!
 Load DLL from `%AppData%\LocalLow' and run payload for entrypoint
 ASLR is not an issue
 DLLs loaded at same address regardless of IL  Fetch kernel32!LoadLibrary address at runtime (Low-IL)
 Write it to spray.pdb
 How to control kernel32!LoadLibrary argument?
 Different calling conventions
33

Dbghelp Gadget (Arguments Reorder)

virtual long __thiscall DbhStackServices::GetSegmentDescriptor(..)

mov push mov ... mov push push mov mov push call call

edi, edi ebp ebp, esp
edi, ecx ; Put `this' in edi (`this'=0x0c0c0c0c) 0 2Ch ; ',' esi, [edi+0Ch] ; Get next virtual func address, from `edi+0Ch' ecx, esi dword ptr [edi+4] ; Push an argument on stack, from `edi+4' ds:___guard_check_icall_fptr esi

34

Demo #1
35

Escape Internet Explorer EPM Sandbox

 Enhanced Protected Mode - Low IL+AppContainer
 iexplore.exe(Low+AC) -> WerFault.exe(Medium)
 PDB bug behaves differently
 Fake Object*/_HEAP_ENTRY points to a kernel-mode address  LFH - _HEAP_ENTRY struct is different (ExtendedBlockSignature vs UnusedBytes)

(b00.990): Access violation - code c0000005 (first chance)

dbghelp!ModCache::pbSyms+0xe:

6db12abe 8b8364010000 mov

eax,dword ptr [ebx+164h] ds:002b:880002d8=????????

0:000> dd @edx-4 L4 007306ec 88000174 007076c0 007316f8 00731878

0:000> !heap -x @edx

Entry

User

Size PrevSize Unused Flags

-----------------------------------------------------------------

007306e8

007306f0

0

-

8 LFH;busy

36

Escape Internet Explorer EPM Sandbox
 Process creation is allowed from IE's sandbox  Create a child process and exploit the bug from there
 iexplore.exe(Low+AC) -> exploit.exe(Low+AC) -> WerFault.exe(Medium)
37

Demo #2
38

Microsoft Fix (CVE-2021-24090 / KB5000802)
 WerFault.exe no longer parses PDB files
 dbghelp!SymSetExtendedOption  (IMAGEHLP_EXTENDED_OPTIONS)3 = LOAD_SYMBOLS_DISABLED
WerFault.exe:
SymSetExtendedOption(3, TRUE); v33_Ret = SymInitialize(v11_CrashingProc, NULL, TRUE);
Dbghelp.dll:
if (SymGetExtendedOption(3)) { _pwprint(L"load symbols is disabled!\n"); return 4; }
39

Takeaways
 Fuzzing is very efficient for the right targets  Exploit works despite all mitigations
 32bit compatibility layer isn't as strongly mitigated
 One bug, multiple attack surfaces  CVE-2021-24090 doesn't fix Dbghelp.dll bug
 Can you find other attack surfaces?

@galdeleon
40

