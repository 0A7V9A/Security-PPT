ON ESP32: TIME TO RELEASE HW EXPLOITS
LimitedResults Black Hat Europe 2019 2-5 December 2019, London
1

$ whoami
·Limited
·By the Time, $$$, my Skills...
·Results
· www.LimitedResults.com
·Offensive Side
·Focus on HW, Low-Level
Vulns...
·No Affiliation ·Time to play!
2

POWER ON
INTRODUCTION
3

The Entry Point
·Last April, I decide to break investigate into the
ESP32
·System-on-Chip (SoC) released in 2016 by Espressif ·Widely-deployed (> 100M of devices) [1] ·Wireless MCU/SoC Market leader ·Claim to have `State-of-the-Art' Security ·12 years-longevity commitment
·General Use
· IoT ·Wireless peripheral
4

The target
·ESP32
· Techno 40nm node · QFN 6*6, 48 pins
·Overview
· Wi-FI (2.4GHz) & BT v4.2 · Ultra Low-Power Xtensa Dual-Core
LX6
· up to 240MHz · ROM, SRAM, no CPU caches
· GPIOs, Touch sensor, ADC... · 4 SPI, 3 UART, Ethernet...No USB
5

ESP32 Form Factor
· ESP32 SiP module (ESP32-WROOM-32)
· Easy to integrate in any design · Flash storage 4MB · FCC certified
· ESP32 Dev-Kit (Lolin ESP32)
· Micro-USB
· Power · ttyUSB0 port · Pin headers
· Limited Cost = 15$
6

ESP32 Software
·Esp-idf Dev. Framework on Github
·xtensa-esp32-elf toolchain ·Set of Python Tools (esptool)
·Good Quality of Documentation
·Datasheet and TRM available [2]
·Arduino core supported
·I don't like pre-compiled libraries, I don't use it
·Official Amazon AWS IoT Platform
·FreeRTOS, Mongoose OS...
7

Agenda Today
·Focus on Built-in Security
· Just Grep the Datasheet
·Four Points
· Crypto HW accelerator ·Secure Boot · Flash Encryption · OTP
·Time to pwn!
8

OPTIONS MENU
SETTINGS
9

The Limited Plan
·The Context
·3 months to investigate (spare time)
·My Objective
·Break one by one the Security Features
· Physical Access Required (plausible attack scenario today)
·So, I will probably use HW Techniques
·Fault Injection, Side Channel maybe? ·Micro-soldering, PCB modification · Reverse ·and Code Review 
10

Voltage Fault Injection
·aka Voltage glitching
· Well-known, still efficient and Low-cost FI technique nowadays · Public ressources about voltage glitching [3][4][...]
·Perturb the Power Supply to induce a fault during critical
SW/HW operations
·Expected effects
·Skip instruction · Data/Code modification
·Unexpected effects
· Difficult to predict/understand faults in complex CPU
architecture (due to Cache effects, Pipeline...)
11

Power domains inside ESP32
· 3 separate Power domains · CPU domain shares two Power Signals
· VDD3P3_CPU && VDD3P3_RTC
· Low Drop-out regulators (LDO)
· Stabilize internal voltages
· Filter effect against glitches?
· Brownout Detector (BOD)
· « If the BOD detects a voltage drop, it will trigger a signal shutdown
and even send a message on UART »
· Able to detect glitches?
· BoD only effective on VDD_RTC · So, I will Glitch on VDD3P3_CPU
12

Target Preparation
· ESP-WROOM-32 Module
· Shield is removed
· No silkscreen but Schematic available · I remove Capacitors connected to VDD_CPU and VDD_RTC
13

PCB Modification
· Three steps
· Exposing the VDD_CPU trace (Pin 37) · Cutting the trace · Soldering the glitch output to VDD_CPU and GND
14

HW Setup
·Home-made Glitcher (10$)
· Based on MAX4619 · Add passive components, SMA
connectors
·Synchronised by Scope ·Triggered by Signal Generator
· USB commands to set parameters
· Delay · Width · Voltage
·Python scripts for full-control
· Can run during days...
15

Voltage Glitching effect

·Effect looks good

UART (powered by VDD_CPU)
GPIO cmd

glitch effect

16

LEVEL 1
THE CRYPTO-CORE
17

Crypto-Core/ Crypto-Accelerator
·Just a peripheral to speed-up the computation
· AES, SHA, RSA...
·Why is it interesting to pwn?
· Espressif Crypto-Lib · HW accel. used by default in MBedTLS
· MBedTLS is the ARM crypto-library (all IoT are using it)
·My Goal
· Focus on the CPU/Crypto interface (crypto-driver)
· Do not expect to find `pure' Software Vulns
· Looking for vulns triggered by Fault Injection
·It is Time for Code Review
18

Design Weakness
·AES operation
· Datasheet
·Design Weakness
· AES_TEXT_m_REG registers used to store plaintext and also
ciphertext
·Encrypt-In-Place can be risky
· If something goes wrong during AES call, pretty sure I can
retrieve the plaintext
·Pretty cool & simple to exploit as first PoC
19

Vuln n*1 = AES Bypass
· Previous Weakness is confirmed · Multiple spots to trigger
·AES start ·The while condition ·The last For loop
· PoC
·Output = Input
20

Vuln n*2 = AES SetKey
·Vuln to trigger
·Unprotected for loop
to load the key into the crypto-core
·PoC
·Key zeroized ·Persistent key value
until the next setkey()
·Nice for attacking AES
Cipher Block Chaining Mode
21

Crypto-Core Conclusion
·Crypto-core does not improve security ·Six Vulns with PoCs in AES and SHA
· Espressif HwCrypto in esp-idf 4.0 (patched since) · ARM MbedTLS v2.13.1 (patched?)
·Resp. disclosure
· No answer from Espressif & ARM during 1 month  · Silent Patch attempt  · BugBounty Program from ARM MBedTLS is Fake 
·I am was a little bit in a FURY ·...ready to pwn harder
22

LEVEL 2
SECURE BOOT
23

Role of Secure Boot
·Protector of FW Authenticity ·Avoid FW modification
· Easy to flash malicious Firmware in SPI Flash · CRC? Not sufficient sorry...
·It will Create a Chain of Trust
· BootROM to Bootloader until the App
·It Guarantees the code running on the device is
Genuine
· Will not boot if images are not properly signed
24

Sec. Boot during Production
·Secure Boot Key (SBK)
· SBK burned into E-Fuses BLK2 · This SBK cannot be readout or modified (R/W protected) · Used by bootROM to perform AES-256 ECB
·ECDSA key pair
· Created by the App developer · Priv. Key used to sign the App, Pub. Key integrated to bootloader.img
·The Bootloader Signature
· 192 bytes header = 128 bytes of random + 64 bytes digest
· Digest = SHA-512(AES-256((bootloader.bin + ECDSA PK), SBK))
· Random at 0x0 in Flash Memory layout, digest at 0x80
25

Sec. Boot on the Field
·Boot process
·Verification Mechanisms
· BootROM (Stage 0)
· Compute Digest with SBK and compare with 64-bytes Digest at 0x80
· ECDSA verification by the Bootloader (Stage 1)
· Micro-ECC is used
·I will Focus on Stage 0
· Signature based on Symmetric Crypto · SBK = AES-Key used to sign the bootloader (CRITICAL ASSET) stored in
E-Fuses, R/W protected
26

Set the Secure Boot
·Can be done automatically by ESP-IDF Framework... ·But I prefer to do it manually
· Burn the Secure Boot Key into BLK2
· $ espefuse.py burn_key secure_boot ./secure-bootloader-key-256.bin
· Burn the ABS_DONE fuse to activate the sec boot
· $ espefuse.py burn_efuse ABS_DONE_0
·E-Fuses Map
· espefuse.py summary
·Look JTAG fuse 
27

Secure boot in Action

·Signed Code (using
SBK)

· Unsigned Code (no Key)

· ·make flash, then it runs Flash it then Fail

· Stuck in stage0, perfect
28

Bypass the Sec.Boot
·Why?
·to have code exec
·How?
·Force ESP32 to execute my unsigned bootloader to load
my unsigned app
·Focus on BootROM
·Always Nice to exploit BootROM vulns, and always
difficult to Fix BootROM vulns
·So, I need to reverse the bootROM ·But first, I need to dump it...
29

Dump the BootROM
·Memory map
·Remember I didn't burn JTAG
DISABLE E-Fuse?
·FT2232H board (20$) ·OpenOCD + xtensa-esp32-gdb
·Full Debug Access
·Reset Vector 0x40000400
·BootROM dumped
30

BootROM Reverse
·Xtensa is `exotic' arch
·registers windowing, lengths of instr... ·ISA [5]
·IDA
·ida-xtensa plugin from @themadinventor
·Secure_boot.h
·List all the ROM functions (deprecated
since...)
·Call a friend to check my mess
· @wiskitki
·At the end, not perfect but doable
·_start at 0x40000704 (as expected)
31

The BootROM Vuln
·After ets_secure_boot_check_finish()
·Bnei (Branch if not equal immediate)
· Depends on a10 Register storing sec_boot_check_finish()
retvalue
·I want PC jump to 0x400075C5 to execute the bootloader
32

Jtag Exploit Validation
·Set a10 register = 0 via JTAG to bypass secboot
33

Time to Pwn (for Real)
·Real Life
· JTAG is disabled · I could not find a way to
exploit this Vuln by SW
·So, Fault Injection is
my only way here
· Simultaneous glitch on
VDD_CPU && VDD_RTC
· SPI MOSI is probed to
have a timing information
34

FI attempt during Boot
·Previous BootROM Reverse is helpful
· to determine Fault injection Timing

ZOOM Serial
SPI

glitch effect
Failed
35

Successful Sec.Boot Bypass
·CPU is jumping to the entry point,
Bootloader is executed

ZOOM Serial
SPI

glitch effect
Validated
36

PoC Secure Boot
·Sorry for the tilt
37

Secure Boot Conclusion
·Secure Boot Bypass exploit
· bootROM Vuln triggered by Fault Injection · Not persistent if Reset occurs · No way to Fix this without ROM revision
·Resp. disclosure
· PoC sent on June 4, Posted on September 1 · Security Advisory on Sept. 2
· CVE-2019-15894 (requested by Vendor) · Patched by Flash Encryption always enabled · A security lab, called Riscure, found the same vuln
·Job done
38

LEVEL 3
FLASH ENCRYPTION
39

Role of Flash Encryption
·Protector of FW Confidentiality
· Protect against binary Reverse
·Without FE, it is easy to
extract sensitive data
· LIFX Wi-Fi lightbulb [6]
·Firmware Encryption more and
more present Today
·Espressif recommends Secure
Boot + Flash Encryption for maximum Security
40

Flash Encryption Review
·HW Enc./Dec. Block in Flash
Memory Controller
· Fetch Key from E-Fuses and
other parameters
· Decrypt/Encrypt I/D into a
Cache
·SW cannot access
·Flash Encryption Key (FEK)
· AES-Key used to decrypt the FW
· Stored in E-Fuses BLK1 (R/W
protected)
· CRITICAL ASSET (of course)
41

Set the Flash Encryption
·Burn the FEK into BLK1
·$ espefuse.py --port /dev/ttyUSB0
burn_key flash_encryption my_flash_encryption_key.bin
·Activate the Flash Encryption
·$ $ espefuse.py burn_efuse
FLASH_CRYPT_CONFIG 0xf
·$ espefuse.py burn_efuse
FLASH_CRYPT_CNT
·Flash encrypted FW into ESP32 ·E-Fuses Map ·Fw is encrypted
42

How to break Flash Encryption?
·I did some tests (believe me...)
·Did not find particular Weakness to access the Key by SW ·Did not find a way to Attack by DFA
·My Last Hope was Side Channel Analysis to target the
Bootloader Decryption
·But my setup was too `limited'
·SPI bus producing a lot of Noise ·Cannot control the SPI frames properly ·I tried DPA, CPA... but not enough leakage
·One week later, no result...
43

Flash Encryption Conclusion
·I lost...
44

EXTRA-COIN
OTP/E-FUSES: THE MOTHER OF VULNS
45

Role of OTP/E-Fuses
·One-Time-Programmable (OTP) Memory based on E-Fuses in ESP32
· An e-Fuse can be `programmed' just `One-Time' from 0 to 1 · Once burned, no possibility to rewrite it or to wipe it
·Organisation
· EFUSE_BLK0 = ESP32 configuration · EFUSE_BLK1 = Flash Encryption Key (FEK) · EFUSE_BLK2 = Secure Boot Key (SBK) · EFUSE_BLK3 = reserved for User Application
·According to Espressif, these E-Fuses are R/W protected and
cannot be readout/modified once protection bits set
·E-Fuses are managed by the E-Fuses Controller, a dedicated piece
of HW inside the ESP32
46

ESP32 E-Fuses Reverse
·Only two identified functions
·efuse_read and efuse_program
·Used during a `Special Boot mode'
· interesting...
·BootROM never touch OTP values ·It means only the E-Fuses
Controller has access to OTP
·Pure HW Process ·Has to be set before BootROM
execution
47

Special Boot Mode
·ESP32 in Special Boot Mode (Download_Boot)
·Management mode to Flash FW, and Set E-Fuses ·IO0 connected to GND then Power-up
·Esptool is python utility to communicate
with the ROM functions
·Dedicated commands available from UART0 to deal
with E-Fuses
· dump, program,...
48

E-Fuses Protection
·Any attempt to read BLK1 or BLK2 returns 0x00
· $ espefuse.py --port /dev/ttyUSB0 dump
·Identification of R/W Protection bits in BLK0 ·00130180 = 00000000 00010011 00000001 1000 0000
· These two bits are the Read protect bits
49

Wait LR, where is the Vuln?
·I have no Vuln here sorry... ·But I know
· BootROM does not manage the E-Fuses · Obviously, E-Fuses Controller does the job before · Special boot mode called `Download_Boot' · Read protection bits have been identified
·The idea
· Glitch the E-Fuses Controller initialization to modify the R/W
protections
· Then send Dump command in Special Mode · Readout BLK1 (FEK) and BLK2 (SBK)
50

FATAL Glitch
·Simple Power Analysis to identify HW process ·Glitch during this identified activity

ZOOM

Serial Current

3V3 cmd

glitch effect 51

FATAL Results
·SBK and FEK extracted from eFuses
52

One more step
·Sadly, the dumped Keys are
not exactly True values
·Remember I burned the keys 
·Offline Statistical Analysis
on 30-50 dumped key values
·just Keep the most recurrent
Bytes (here SBK analysis)
·1 Byte still unknown and has
to be Brute Forced (worst case)
·Same for FEK
53

FATAL Exploit step 1: Decrypt FW
·Dump the encrypted FW
·By Download Mode or by dumping Flash
·Perform FATAL Glitch to extract FEK and SBK
·Run Statistical analysis
·Confirm the True FEK (by decrypting FW)
·Respect the bytes order in binary file
·
54

FATAL Exploit step 2: Sign Your Code
·Firmware is now decrypted ·dd ivt.bin (the first 128 random
bytes at 0x00 in decrypted.bin)
·dd Bootloader.bin at 0x1000 ·Confirm the true SBK
· digest computation command
·Write your Code
· a little FW backdoor maybe? 
·Compile images
· using FEK and SBK
·Flash new FW
55

OTP/EFuses FATAL Conclusion
·FATAL exploit leading to SBK and FEK extraction
·Breaking Secure Boot and Flash Encryption
·An attacker can decrypt the Firmware (and access
sensitive data)
·An attacker can sign & run his own (encrypted) code
PERSISTENTLY
·Low Cost, Low Complexity ·Easy to reproduce ·No Way to fix ·All ESP32 versions vulnerable
56

Vendor Reaction
·Resp. disclosure
·PoC sent on July 24 ·CVE-2019-17391 (req. by Vendor) ·Posted on November 13
·Security Advisory on November 1 [7]
·No way to Fix but...you can buy the next version  ·Millions of vulnerable Devices on the field for
the coming years
57

The impact
·For Hobbyists
· Don't worry, your `connected DIY device' is safe 
·For Developers
· In case you are using the ESP32 security features to protect
SECRETS, you should be worried...
· FYI, I identified 3 companies using ESP32 Flash Enc. and
Sec.Boot in their products to protect their `business model'
·For the vendor
· Force to modify silicon to save his longevity commitment and
his reputation
· What about current devices offered for sales?
58

Final Conclusion

·Attacker with physical access can
compromise ESP32 security badly
· PERSISTENT Bypass of Secure Boot +
Flash Encryption
·Fix?
· No fix on current ESP32 version
·Platform is broken
· A new chip version will be released
·General Message for Vendors
· Don't patch silently
·New Results coming soon, stay
tuned!
59

End of the game

References & Credits
·Espressif
· [1] Espressif 100-Millions chip shipments
·ESP32
·[2] Datasheet, TRM
·Fault injection references
· [3] Chris Gerlinsky (@akacastor) · [4] Colin O'Flynn (@colinoflynn)
·Xtensa
·[5] ISA Manual
·LIFX Pwn
·[6] LIFX Pwn
·Security Advisory
·[7] CVE-2019-17391
·Fatal Fury Animations
60

Thank you!
@LimitedResults www.limitedresults.com
Black Hat Europe 2019

