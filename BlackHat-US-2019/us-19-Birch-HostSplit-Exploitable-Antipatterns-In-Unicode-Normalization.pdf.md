Host/Split
Exploitable Antipatterns in Unicode Normalization
Jonathan Birch, Microsoft Office Security jobirch@Microsoft.com

This talk is about new Unicode vulnerabilities
З Not homographs.
З A lot of software needs to get fixed. Maybe your software.

Agenda
З Background: How Unicode Hostnames (IDN's) work З The HostSplit attack ­ making URL's that switch domains З Example exploit ­ stealing OAUTH tokens from O365 З What was vulnerable / what's still vulnerable З HostBond - a variant attack З How to test / Best practices

Why attack Unicode URL's?
З Story time: Pen-Test Lunch at Microsoft
З In 2017 Egyptian hieroglyph URL's became available.

I got this one
.net
З Yes, that's a man simultaneously riding two giraffes. З But how does that work?

Background: How do IDN's work?

It's all ASCII Underneath
.net ToASCII xn--fq7d.net ToUnicode

U-Label

A-Label

Unicode  ASCII ­ A Two Step Process
1. Normalization Convert characters to a "standardized form".
2. Punycoding Turn Unicode into ASCII.

Unicode  ASCII: Normalization Х (U+00C5)

 (U+212B) Х (U+0041, U+030A)

Normalize To

х (U+00E5)

Unicode  ASCII: Punycoding
FISKMХS

xn--fiskms-mua

ACE (Means this is
Punycode

ASCII Stuff

State-machine instructions

ASCII  Unicode is Simple
З Just run the Punycode state machine and rehydrate the Unicode.
З RFC 3490 (IDNA) says the resulting U-label should have "ToASCII" run against it and we should fail if the result doesn't match our input...

Three different specs for how this works

IDNA2003
The original

IDNA2008
The second try

IDNA2008 + UTS46
A compatibility patch

The HostSplit Vulnerability

Revisiting Unicode Normalization
З Remember that "normalization" step?
З "Х" became "х"
З What if there were Unicode characters that normalized to ASCII characters with syntax-significance?

Unicode Normalizing to Control Characters



Normalizes To

(U+2100) "Account Of"

a/c
ASCII: a, forward slash, c

Splitting Hostnames
https://evil.c.Example.com
What happens if we perform ToASCII against this?

Splitting Hostnames
https://evil.c.Example.com
Normalizes To
https://evil.ca/c.Example.com
No need to Punycode anything ­ it's all ASCII now!

Does this really work?
З Yes, though not as broadly as it did when I started.
З The first vulnerability I found like this was in Edge and IE.
З Similar issues existed in .Net, Python, and Java.

The Edge / IE Vulnerability

When Edge received a redirect with this location header:

https://evil.c.Example.com

???

It redirected to:

https://evil.ca/c.Example.com

But why does this matter? How do we exploit it?

Attacking OAuth with HostSplit

Attacking OAuth

OAUTH Authorization Code Flow (RFC 6749 4.1)

Client web site

Application ID, Redirect URI
Authorization Code
(Sent to redirect URI)

Authorization Server

З This is only secure because the authorization server has an allow list pattern for the redirect URI's it accepts for any given application ID.
З But how does this allow list pattern work?

OAuth Redirect Allow Lists
З In OAuth 1.0 patterns like "*.office.com" were common.
З A URI like "http://evil.c.office.com" would work.
З Nobody normalizes URL's before comparing - the check just says, "Does the string end with .office.com?"

HostSplit vs. OAuth 1.0

Hostname ends with
office.com Looks good!

OFFICE_APP_ID, https://evil.c .office.com
Attacker web site

Authorization Server
Redirect is https://evil.c.office.com Edge goes to https://evil.ca/c.office.com

Evil.ca

Authorization Code

What about modern OAuth?
З Recent OAUTH implementations have more restrictive allow list patterns.
З A specific hostname is usually required (no wildcards).
З The attack I've described so far only let's us fool a subdomain check.

Redirects to the rescue?
З In 2014, a researcher named Wang Jing publicly disclosed a vulnerability he called "Covert Redirect".
З Essentially: "If you can get an OAUTH token sent to an open redirect, you can sometimes steal it."
З This met with a mixed reception. З But HostSplit makes it much easier to find open redirects.

Attacking Office OAuth
З Office.live.com received Office OAUTH tokens and had a redirect that went to dropbox.com or any subdomain of it.
З This URL as an OAUTH target would let you steal tokens:
https://office.live.com/start/word.aspx?h4b=dropbox&eurl=htt ps://evil.c.dropbox.com/wopi_edit/document1.docx&furl=htt ps://www.dropbox.com/wopi_download/document1.docx&c4b =1
З Well, almost.

Saved by a bug
З Middleware in front office.live.com double-encoded UTF-8 response headers.
З The redirect actually went to: https://evil.cУЂттЌ.dropbox.com/wopi_edit/document1.docx
З This put us in an awkward position.

What's vulnerable to HostSplit?

More than the example

З Not just OAUTH З Not just Edge
З Not just :
U+2048  U+FF0F  U+FF03 U+FF20 

U+FF1A U+2488  U+FE47 
And many others...

IDNA Version Matters
З IDNA2008 blocks HostSplit-enabling characters. З IDNA2003 and IDNA2008 + UTS46 are vulnerable. З The "UseSTD3ASCIIRules" flag fixes these by blocking the
bad characters. З Why doesn't everyone use either IDNA2008 or this flag?

Blame Underscores
З UseSTD3ASCIIRules only allows alphanumerics, dashes, and periods.
З Lots of real-world hostnames contain underscores (mostly old intranet stuff).
З Many implementations use IDNA2008 + UTS46 without STD3 rules so that they can still connect to hosts with underscores in them.

Browsers are safe now
З Edge and IE vulnerabilities were fixed as CVE-2019-0654 in February of 2019.
З They now refuse to follow HostSplit HTTP redirects. З Firefox and Chrome were already safe. З Safari is probably also safe, but it percent-encodes
dangerous Unicode characters for some reason.

.NET was vulnerable
This used to output "http://canada.ca/c.products.office.com/test.exe"

.NET is fixed
З Patched as CVE-2019-0657 in February 2019
З The logic used now is:
1. Identify that the URI contains a host name that will be resolved via DNS.
2. Isolate the host name, removing port + authentication. 3. Encode only the host using IdnToAscii 4. Check the output to ensure no URI control characters have been
added to the host. (M. Kerr, 2018)
UriBuilder now throws a System.UriFormatException if you give it a URL like the one on the previous slide.

Fiddler was vulnerable (because of .NET)
З Telerik's Fiddler tool runs on .NET, and if you had it intercepting traffic, it would "fix" all location headers so that the Edge/IE bug worked in every browser.
З This got better when Microsoft fixed .NET.

Python was vulnerable

>>> from urllib.parse import urlsplit, urlunsplit З Credit for this

>>> url = 'http://canada.c.microsoft.com/some.txt' vulnerability is shared

>>> parts = list(urlsplit(url))

with Panayiotis

>>> host = parts[1]

Panayiotou

>>> host

'canada.c.microsoft.com'

>>> newhost = []

>>> for h in host.split('.'):

...

newhost.append(h.encode('idna').decode('utf-8'))

...

>>> parts[1] = '.'.join(newhost)

>>> finalUrl = urlunsplit(parts)

>>> finalUrl

'http://canada.ca/c.microsoft.com/some.txt'

Python had an extra variant

>>> from urllib.parse import urlparse

>>> r='http://bing.com'+u'\uFF03'+':password@products.office.com'

>>> o = urlparse(r)

>>> o.hostname

'products.office.com' >>> a = r.encode("IDNA").decode("ASCII")

(FULLWIDTH NUMBER SIGN)

>>> a

'http://bing.com#:password@products.office.com'

>>> o = urlparse(a)

>>> o.hostname

'bing.com'

Python is fixed
З Original issue was patched as CVE-2019-9636 З Variant using basic auth patched as CVE-2019-10160

Java was vulnerable
This output http://evil.CA/B.Microsoft.com

Java is fixed
З Patched as CVE-2019-2816 / S8221518 in July 2019

Your Windows code might still be vulnerable
З The Windows API IdnToASCII converts "" to a/c.
З This is necessary ­ IdnToASCII isn't only used for hostnames, so keeping it compliant with the standard is critical.
З IDN_USE_STD3_ASCII_RULES flag makes IdnToASCII safe. This also forbids underscores though.

Your Linux code might still be vulnerable
З LibIDN and LibIDN2 also convert "" to a/c. З The usestd3asciirules flag makes LibIDN safe. З The no-tr46 flag makes LibIDN2 safe. З I contacted bug-libidn@gnu.org about this in February of
2019, and they said it was by design.

HostBond: a variant attack

Characters only allowed in IDNA2008
З "ZERO-WIDTH JOINER" (U+200D) and "ZERO-WIDTH NON-JOINER" (U+200C) are deleted during normalization in IDNA2003.
З They're invisible and make visual spoofing too easy.
З But these characters are important for some languages as a way of changing ligatures. ( vs )
З IDNA2008 allows these, but only if the characters on either side of them would be visually changed.

ToASCII vs ToUnicode
З In IDNA2008, a string like "micro" + zero-width-joiner + "soft" has the zero-width-joiner (ZWJ) thrown away during normalization.
З Many implementations of ToUnicode don't make sure that the result has appropriate neighbors for decoded ZWJ's.
З So the same string with the ZWJ already encoded is just fine:
xn--microsoft-469d.com

Vanishing ZWJ's
There are two problems with a URL like
xn--microsoft-469d.com:
1. The zero-width joiner is invisible, so the U-Label for this is microsoft.com (there's a ZWJ there ­ you just can't see it). 2. Since the zero-width joiner isn't technically allowed, it won't survive being converted to Unicode and then back to ASCII.

The Hostbond Vulnerability
З Someone has a mail server at email.somecloudhost.net, and we want to impersonate them.
З We register our own domain with a Punycoded zero-width joiner in between the "e" and the "m":
xn--email-xt3b.somecloudhost.net
З What happens if we send email from our server?

HostBond Exploit - Gmail
З If we send email to Gmail from "admin@xn--emailxt3b.somecloudhost.net", they decode it.
З The email shows up as having come from admin@email.somecloudhost.net
З SPF and DKIM are checked against the xn--email-xt3b version.
З If you reply, Gmail throws away the ZWJ, so it goes to the real admin@email.somecloudhost.net

HostBond Exploit - Gmail
З I reported this vulnerability to Google in February of 2019.
З They have acknowledged the report but have yet to make any fixes.
З They are actively working on the issue and monitoring for exploits.

LibIDN2 was vulnerable to HostBond
echo "xn--microsoft-469d.com" | idn2 ­d micro soft.com
Zero-Width Joiner
З Fixed as CVE-2019-12290 in version 2.2.0 of LibIDN2 З Credit shared with Tim Ruehsen (GNU libidn), Florian
Weimer (GNU glibc) and Nikos Mavrogiannopoulos (GnuTLS)

HostBond - Limitations
З Only works against IDNA2008. З Only exploitable when you can provide a Punycoded URL
that will get decoded ­ usually requires UI. З Domain registrars block creation of hostnames like these. З But providers of third-level domains generally allow these
hostnames.

Testing for HostSplit and HostBond

How to test for HostSplit
З Insert a magic character into a URL field and see what it resolves to.
З It's easy if you can monitor network traffic. Look at DNS.
З http://canada.c.bing.com works.

A better HostSplit test case
Some domain where you log requests.
http://a.comX.b.com
(Fullwidth Solidus [U+FF0F])

Map all b.com subdomains to the same server, log requests.

Requests that go to "a.com" are vulnerabilities. So are DNS lookups for a.com

How to test for HostBond
З If you have code that renders a user-provided hostname and might try to de-Punycode it, make sure it only decodes valid IDN's.
З There are three test cases worth trying here:
1. Zero-width joiner: "xn--TC-m1t.com" should not become "TC.com". 2. Bubble numbers: "x--orh.com" should not become ".com" or
"1.com". 3. Greek question mark: "xn--ab-y4b.com" should not decode to
"a;b.com".

HostBond isn't just a web vulnerability
З Email (SMTP), IM (SIP/SIMPLE/MSRP), and other Internet protocols that use hostnames are also potentially vulnerable.
З For email: try sending mail with an extra recipient that has bad Punycode in the hostname, like test@xn--bing-676a.com ­ this should not render as test@bing.com

Best Practices for Unicode URL's

Make all hostname decisions using ASCII
З Only A-labels should be used for security decisions.
З Software that tries to compare or filter hostnames should run some version of ToASCII on them first.
З Lots of platform code does this wrong.

UseSTD3ASCIIRules
З Use your platform's version of "UseSTD3ASCIIRules".
З This flag ensures that Unicode normalization does not introduce syntax-significant characters into a URL.
З This flag blocks hostnames with underscores, so don't use underscores in hostnames.

Wrap bad platform code
З Lots of API's are vulnerable to HostSplit.
З To fix these, extract the hostname first then compare after calling the API to make sure no new syntax characters appeared.
З Many API's will decode invalid Punycode. Wrap these in a function that adds the round-trip check.

Go make this better, please.
З Test software for Unicode normalization vulnerabilities.
З Require URL's be compared as ASCII.
З Hack stuff (ethically!) ­ that makes things better too.

Questions?
jobirch@Microsoft.com

CVE's and Credits
З CVE-2019-0654 Microsoft Browser Spoofing Vulnerability З CVE-2019-0657 .NET Framework and Visual Studio Spoofing Vulnerability З CVE-2019-9636 Python, urlsplit does not handle NFKC normalization
З Credit shared with Panayiotis Panayiotou З CVE-2019-10160 Python, urlsplit NFKD normalization vulnerability in user:password@ З CVE-2019-2816 Oracle Java SE/Java SE Embedded, "Normalize normalization" З CVE-2019-12290 LibIDN2, "Perform A-Label roundtrip for lookup functions by default"
З Credit shared with Tim Ruehsen (GNU libidn), Florian Weimer (GNU glibc) and Nikos Mavrogiannopoulos (GnuTLS)
З Special thanks to Tina Zhang-Powell of MSVR, for helping to coordinate these fixes.

References
З Hoffman, P. and M. Blanchet, "Preparation of Internationalized Strings ("stringprep")", RFC 3454, DOI 10.17487/RFC3454, December 2002, <https://tools.ietf.org/html/rfc3454>.
З Faltstrom, P., Hoffman, P., and A. Costello, "Internationalizing Domain Names in Applications (IDNA)", RFC 3490, DOI 10.17487/RFC3490, March 2003, <https://tools.ietf.org/html/rfc3490>.
З Thaler, D., Ed., "Issues in Identifier Comparison for Security Purposes", RFC 6943, DOI 10.17487/RFC6943, May 2013, <https://tools.ietf.org/html/rfc6943>.
З Kerr, Max (Personal Communication August 27, 2018) З Goldmann, Mikael, " Creative usernames and Spotify account hijacking", June
2013, <https://labs.spotify.com/2013/06/18/creative-usernames/>

Table of potential URL-splitting characters

З U+2100,  З U+2101,  З U+2105,  З U+2106,  З U+FF0F,  З U+2047,  З U+2048,  З U+2049, 

З U+FE16,  З U+FE56,  З U+FF1F,  З U+FE5F,  З U+FF03,  З U+FE6B,  З U+FF20, 

