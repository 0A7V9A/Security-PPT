Exploiting Qualcomm WLAN And Modem Over-The-Air
· Xiling Gong, Peter Pi · Tencent Blade Team

Exploiting Qualcomm WLAN And Modem Over-The-Air
Xiling Gong, Peter Pi Tencent Blade Team

About Us
Xiling Gong (@GXiling)
Senior security researcher at Tencent Blade Team. Focus on Android Security, Qualcomm Firmware Security. Speaker of BlackHat, CanSecWest.
Peter Pi(@tencent_blade)
Senior security researcher at Tencent Blade Team. Find many vulnerabilities of vendors like Google, Microsoft, Apple, Qualcomm, Adobe and Tesla. The #1 Researcher of Google Android VRP in year 2016. Speaker of BlackHat, CanSecWest, HITB, GSEC and Hitcon.

About Tencent Blade Team
· Founded by Tencent Security Platform Department in 2017 · Focus on security research in the areas of AIoT, Mobile devices, Cloud
virtualization, Blockchain, etc · Report 200+ vulnerabilities to vendors such as Google, Apple, Microsoft, Amazon · We talked about how to break Amazon Echo at DEFCON26 · Blog: https://blade.tencent.com

Agenda
· Introduction and Related Work · The Debugger · Reverse Engineering and Attack Surface · Vulnerability and Exploitation · Escaping into Modem · Escaping into Kernel · Stability of Exploitation · Conclusions

Agenda
· Introduction and Related Work · The Debugger · Reverse Engineering and Attack Surface · Vulnerability and Exploitation · Escaping into Modem · Escaping into Kernel · Stability of Exploitation · Conclusions

Introduction
· Broadcom WIFI Chip
· 2017, Gal Beniamini
· Over The Air: Exploiting Broadcom's Wi-Fi Stack
· 2017, Nitay Artenstein, BlackHat USA 2017
· BROADPWN: REMOTELY COMPROMISING ANDROID AND IOS VIA A BUG IN BROADCOM'S WI-FI CHIPSETS
· Marvel WIFI Chip
· 2019, Denis Selyanin
· Zero Nights 2018 , Researching Marvell Avastar Wi-Fi: from zero knowledge to overthe-air zero-touch RCE
· Blog 2019, Remotely compromise devices by using bugs in Marvell Avastar Wi-Fi: from zero knowledge to zero-click RCE
· How about Qualcomm WIFI?

Qualcomm WLAN (MSM8998)

Application

Android Framework

Linux Kernel

Full MAC Layer

QCACLD2/3

Wifi Demon

Baseband Subsystem

Modem Firmware

WLAN Firmware

Agenda
· Introduction and Related Work · The Debugger · Reverse Engineering and Attack Surface · Vulnerability and Exploitation · Escaping into Modem · Escaping into Kernel · Stability of Exploitation · Conclusions

MBA and Modem images
· Modem Boot Authenticator · mba.mbn · modem.mdt · modem.b00 ­ modem.b20 · Image format

Modem Secure Boot

pil_boot
· The pil_boot function in Linux Kernel describes the boot flow of modem.
· Load mba.mbn, modem.mdt and modem.bxx to physical memory. · Trigger MBA and modem images to be verified and run in
Modem Processor. · Linux Kernel can restart Modem Processor at any time, will hit
pil_boot each time when restart.

pil_boot
pil_boot start
Load modem.mdt, use the info to setup modem
pa region
Call pil_msa_mss_reset_mba_load_auth_mdt to load msa.mbn and auth modem.mdt
Call pil_mss_mem_setup to register modem pa region to TZ

Call pil_assign_mem_to_subsys_and_linux to make Linux Kernel and MBA both can
access the pa region
Call pil_load_seg to load modem.bxx to the pa region
Call pil_reclaim_mem to make Linux Kernel can't access the pa region any more
Call pil_msa_mba_auth to auth modem.bxx and start modem

TOCTOU Vulnerability

Linux Kernel

MBA

Modify the verified image

Verified

Verifying

modem.b modem.b modem.b

modem.b

DDR

05

06

07

20

POC

Debug Server Injection

Agenda
· Introduction and Related Work · The Debugger · Reverse Engineering and Attack Surface · Vulnerability and Exploitation · Escaping into Modem · Escaping into Kernel · Stability of Exploitation · Conclusions

Qualcomm WLAN

Application

Android Framework

Full MAC Layer

QCACLD2/3

Wifi Demon Linux Kernel

Modem Firmware

WLAN Firmware

Baseband Subsystem Hexagon

Qualcomm WLAN Architecture

Application

Android Framework

Wifi Demon

Full MAC Layer

QCACLD2/3

WMI Handler

Offload MAC Layer

Non-Data Handler

Data Handler

Physical Layer OTA Packet

Linux Kernel WLAN Firmware

Example - Management Beacon
Wifi Demon SSID

Full MAC Layer

QCACLD2/3

Linux Kernel

Offload Table

Forward Non-Data Handler

80211 Management Beacon

Management Beacon

Parse

WLAN Firmware

Discard

Firmware
· Modem load WLAN Firmware from /vendor/firmware/wlanmdsp.mbn
· IDA Disassembler
· https://github.com/programa-stic/hexag00n/tree/master/ida · https://github.com/gsmk/hexagon
· Qualcomm SDK
· https://developer.qualcomm.com/software/hexagon-dsp-sdk/tools
· Instruction Reference
· https://developer.qualcomm.com/download/hexagon/hexagon-v5xprogrammers-reference-manual.pdf?referrer=node/6116

Reverse Engineering ­ Hint From Qualcomm

String Table

WMI Handler

drivers/staging/fw-api-fw/wmi_unified.h

Import Function

Reverse Engineering
· Targets To Reverse
· WMI Handlers
· Handle WMI commands from Linux Kernel · Send back WMI indication to Linux Kernel
· Offload Handlers
· Handle OTA Packets

WMI Handler

Offload MAC Layer

Non-Data Handler

Data Handler

Physical Layer OTA Packet

WMI Handlers
drivers/staging/fw-api-fw/wmi_unified.h
0x03001

Offload Handlers

Sample Offload Handler

OTA Packet Data Pointer =
[0x5B | 0x5A | 0x59 | 0x58]

Agenda
· Introduction and Related Work · The Debugger · Reverse Engineering and Attack Surface · Vulnerability and Exploitation · Escaping into Modem · Escaping into Kernel · Stability of Exploitation · Conclusions

The Roadmap
We are here!

Linux Kernel
WLAN Modem

Mitigation Table (WLAN & Modem)

Mitigation Heap ASLR Heap Cookie Stack Cookie
W^X FRAMELIMIT* FRAMEKEY** Code & Global Data ASLR
CFI

Status Y Y Y Y Y Y N N

*FRAMELIMIT Register - if SP < FRAMELIMIT throw exception **FRAMEKEY Register - Return Address XOR FRAMEKEY. A random integer different for every thread

The Vulnerability (CVE-2019-10540)

Offload Table

Non-Data Handler

Linux Kernel WLAN Firmware Parse

80211 PRE-AUTH-Frame OTA

The Vulnerability (CVE-2019-10540)
Copy items from packet into Global Static Buffer. Max Item Count = 10 Send 11 items -> Overflow!
[GLOBAL] char *GlobalBuffer[10 * 0xB0 + 6];
unsigned int itemCount = 0; for (unsigned int i = 0; i < Length; i += 0x44) {
memcpy (GlobalBuffer + 6 + itemCount * 0xB0, OTA_DataPtr + i, 0x44);
itemCount++; }
* Translated and simplified the code flow

Data & Address of Overflow

Global Buffer +0xB0 * 10

Head (6 bytes)
Item 1 (0xB0 bytes)
Item 2 (0xB0 bytes)
...
Item 9 (0xB0 bytes)
Item 10 (0xB0 bytes) Overflow (0x44 bytes)
(0xB0 ­ 0x44 bytes) Overflow (0x44 bytes)
(0xB0 ­ 0x44 bytes) ...

Smart Pointer Around Overflow Memory

Global Buffer +0xB0 * 10

Head (6 bytes)
Item 1 (0xB0 bytes)
Item 2 (0xB0 bytes)
...
Item 9 (0xB0 bytes)
Item 10 (0xB0 bytes) Overflow (0x44 bytes)
(0xB0 ­ 0x44 bytes) Overflow (0x44 bytes)
(0xB0 ­ 0x44 bytes) ...

+0

0x00000000

+4

0x00000000

+8

0x00000000

+C

SmartPointer

Usage Of Smart Pointer
Char **AddressOfSmartPointer = GlobalBuffer + 6 + 0xB0 * 11 + 0xC; char *SmartPointer = *AddressOfSmartPointer; char *MacAddress = OTA_DataPtr + 0x10; char *BYTE_C = OTA_ DataPtr + 0x10 + 0x20; char *BYTE_D = OTA_ DataPtr + 0x10 + 0x21; char *BYTE_14 = OTA_ DataPtr + 0x10 + 0x22; if (TestBit(SmartPointer, 0) == 1) {
if (memcmp(SmartPointer + 6, MacAddress, 6) == 0) { *(SmartPointer + 0xC) = *BYTE_C; *(SmartPointer + 0xD) = *BYTE_D; *(SmartPointer + 0x14) = *BYTE_14;
} }
* Translated and simplified the code flow

Usage Of Smart Pointer

Char **AddressOfSmartPointer = GlobalBuffer + 6 + 0xB0 * 11 + 0xC;

char *SmartPointer = *AddressOfSmartPointer;

//  Overwrite with vulnerability

char *MacAddress = OTA_DataPtr + 0x10;

char *BYTE_C = OTA_ DataPtr + 0x10 + 0x20;

char *BYTE_D = OTA_ DataPtr + 0x10 + 0x21;

char *BYTE_14 = OTA_ DataPtr + 0x10 + 0x22;

if (TestBit(SmartPointer, 0) == 1) {

//  The only constraint, Bit0 == 1

if (memcmp(SmartPointer + 6, MacAddress, 6) == 0) {

//  From OTA Data, could be bypass

*(SmartPointer + 0xC) = *BYTE_C; //  Overwrite 0xC

*(SmartPointer + 0xD) = *BYTE_D; //  Overwrite 0xD

*(SmartPointer + 0x14) = *BYTE_14;

}

}

* Translated and simplified the code flow

Global Write With Constraint

Step 1 Overwrite SmartPointer

Step 2 Global Write (Using SmartPointer)

SmartPointer

0xXXXXXXXX

0xXXXXXXXX +4 +8 +C

00 00 00 01 00 00 00 00 00 00 00 00 12 34 56 78

+0

00 00 00 01

+4

MA CA 00 00

+8

AD DR ES SS

+C

12 34 ?? ??

Bit 0 MAC Write

Global Write With Constraint How to write 4 bytes?

Step 1 Overwrite SmartPointer

SmartPointer

0xXXXXXXXX

Step 3 Overflow SmartPointer

SmartPointer

0xXXXXXXXX+2

Step 2 Global Write (Using SmartPointer)

+0

00 01 00 01

Bit 0

+4

MACA 00 00

+8

AD DR ES SS

MAC

+C

12 34 ?? ??

Write Low 2 Bytes

Step 4 Global Write (Using SmartPointer)

+0

00 01 00 01

Bit 16

+4

00 00 00 00

+8

MA CA DD RE

+C

?? ?? SS SS

Write High 2 Bytes

MAC

Global Write With Constraint The Bit0 != 1?

-C

00 00 00 01

-8

00 00 00 00

-4

00 00 00 01

+0

00 00 00 00

+4

MACA 00 00

+8

AD DR ES SS

+C

12 34 ?? ??

Bit0 == 1 MAC
Bit0 != 1 MAC Target

Control PC & R0

Address 00 +04 +08 +0C +10 +14 +18 +1C +20 +24 +28

Value 0x00010000 0x00010001 0x00000000 0x00000001 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x12345678(PC) 0x87654321(R0)

Address +00 +04 +08 +0C +10 +14 +18 +1C +20 +24 +28

Value 0x00010000 0x00010001 0x00000000 0x00010001 0x00010001 0x00000000 0x00010001 0x00010001 0x00000000 TARGET PC TARGET R0

SmartPointer

Transform To Arbitrary Write

TARGET PC
TARGET R0
Item1 Payload1
Item2 Payload2
...

FOP Gadget

Run Useful FOP Gadget

Step 1 Arbitrary Write Overwrite function pointer  Function Pointer(PC) Step 2 Arbitrary Write Overwrite data pointer  Data Pointer (R0)

Step 3 Send payload packet and trigger the PC 

Item1 Payload1
Item2 Payload2
...

Memory Mapping RWX

CreateMapping(args, ...)
R0 = 0x42420000 Virtual Address
R1 = 0x936a0000 Physical Address
R2 = 0x1000 Size
R3 = 4 Unknown
R4 = 7 Permission RWX

42420000 Virtual Address RWX

b0000000 R-X

Physical DRAM 936a0000

Memory Mapping RWX

TARGET PC
TARGET R0
Item1 Payload1
Item2 Payload2
...

FOP Gadget

CreateMapping(args, ...)
R0 = 0x42420000 Virtual Address
R1 = 0x936a0000 Physical Address
R2 = 0x1000 Size
R3 = 4 Unknown
R4 = 7 Permission RWX

Copy Shellcode to 0x42420000

Step 1 Arbitrary Write Overwrite function pointer  memcpy(PC) Step 3 Trigger

Step 2 Arbitrary Write Overwrite data pointer  0x42420000(R0) OTA Packet(R1) Packet Len(R2)

0x42420000
Shellcode ...

Trigger Shellcode

Step 1 Arbitrary Write Overwrite function pointer  0xB0000020(PC) Step 2 Trigger

Any Value(R0)

0xB0000020
Shellcode ...

Agenda
· Introduction and Related Work · The Debugger · Reverse Engineering and Attack Surface · Vulnerability and Exploitation · Escaping into Modem · Escaping into Kernel · Stability of Exploitation · Conclusions

The Roadmap

Linux Kernel
WLAN Modem

From WLAN to Modem

Userspace WLAN

Modem

Kernel

QURT OS

Actions From WLAN TLB Set* Write Modem Data Call Modem Complex Function** Call Modem Simple Code Snippet*** Map Modem Memory

Eligible? N N N Y Y

* TLB is a Hexagon Instruction to modify the Memory Page Attribute ** Complex Function uses the resource of Modem, or calls System Call *** Simple Code Snippet mean code has only register operation

Map Modem Memory into WLAN

WLAN Process Virtual Address

WLAN WLAN

Modem RWX

Modem R-X
Modem

Virtual Address Physical Address

Agenda
· Introduction and Related Work · The Debugger · Reverse Engineering and Attack Surface · Vulnerability and Exploitation · Escaping into Modem · Escaping into Kernel · Stability of Exploitation · Conclusions

The Roadmap

Linux Kernel
WLAN Modem

The Attack Surfaces
Userspace APP Linux Kernel TrustZone

AT Command Glink DIAG QMI WMI APR Share Memory

Modem

· We've found
An arbitrary memory read/write vulnerability Could bypass all the mitigations of Linux Kernel
From Modem into Linux Kernel
· In these attack surfaces · But we are unable to disclose the detail now

Agenda
· Introduction and Related Work · The Debugger · Reverse Engineering and Attack Surface · Vulnerability and Exploitation · Escaping into Modem · Escaping into Kernel · Stability of Exploitation · Conclusions

Deliver the Payload Over-The-Air
Pixel 2XL
Packet Losing Rate 90%+!

Deliver the Payloads Using Pixel2

Pixel 2

Pixel 2XL

The Roadmap
Pixel 2

Pixel 2XL
Linux Kernel
WLAN Modem

Demo

Future Works
· There are still lots of mystery in the WLAN.
· We were only reversed a small part of the code · Lots of functions are unknown
· How to fuzz the WLAN Firmware?
· Reverse engineering is quite... · How to fuzz closed source target and Hexagon architecture effectively?
· Translate Hexagon Instruction to C?
· IDA/Ghidra F5 plugin?

Timeline
· 2019-2-14 Find the Modem debug vulnerability on MSM8998 · 2019-3-24 Find the WLAN issue and report to Google · 2019-3-28 Google forwards the issue to Qualcomm · 2019-4-24 Google confirms the WLAN issue as Critical · 2019-5-08 Find the WLAN into Linux Kernel issue and report to Google · 2019-5-24 Google confirms the WLAN into Linux Kernel issue · 2019-5-28 Submit the full exploit chain (OTAWLANKernel) to Google · 2019-6-04 Google reply unable to reproduce the full exploit chain · 2019-6-17 Improve the stability and submit to Google · 2019-7-19 CVE Assigned by Google · 2019-7-20 Qualcomm confirms issues will be fixed before October · 2019-8-0? Google release the fix for Google Pixel2/Pixel3

Takeaways
· The full exploit chain into Android Kernel
· OTA  WLAN  Modem  Kernel
· The Qualcomm WLAN vulnerability and exploitation
· The Qualcomm Baseband Debugger

THANK YOU
https://blade.tencent.com

