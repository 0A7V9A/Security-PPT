PIN Down the Malware:
Using Machine Learning Techniques to Augment IOCs

Andrei Saygo Microsoft

Jason Coleman Microsoft

About us
Who we are. Ninjas. Seriously 

2

Agenda
 IOCs at a glance  Instrumenting with PIN  Our PIN plugin  Classification
- Association rule learning - Naive Bayes classifiers - Feature selection - Call Hashing
 Visualisation  Signatures  Demo  Next steps
3
IOCs at a glance
IOC = Indicator Of Compromise
IOCs are forensic artefacts of an intrusion that can be identified on a host or network.
An IOC (also sometimes just called an Indicator) is a logically grouped set of descriptive terms (each called an "Indicator Term") about a specific threat.
4

IOCs at a glance
They are written in XML and are based on the Open IOC schema (www.openioc.org) More details:
http://openioc.org/resources/An_Introduction_to_OpenIOC.pdf https://www.mandiant.com/blog/openioc-series-investigating-indicators-compromiseiocs-part/
5
Instrumenting with PIN
6

Instrumenting with PIN: About
Dynamic binary instrumentation is a method of analyzing the behaviour of an application by injecting instrumentation code that executes as part of the normal stream of instructions. Our PIN plugin performs:
- API Hooking (for API's of Interest) - Memory Modification Detection (for regions of interest ­heap,
.data etc...) ­ leading to DataViz - Trace executed instructions
7
Instrumenting with PIN
Our PIN plugin -------------------Instrument APIs Log parameters Duplicate Read/WriteFile data to VFS
8

Instrumenting with PIN: PIN plugin

Image instrumentation can inspect and instrument an entire image when it's first loaded.
Instrumentation can be inserted so that it's executed before or after a code sequence is executed.
9

Instrumenting with PIN: PIN plugin

MSDN

API hook

API instrumentation
10

Classification

11

Dynamic Analysis
 We use Intel PIN to instrument the sample under test  The PinTool has been designed to extract features related
to the behaviour of the sample

Process PinTool DLL Process Registry File System Network

Trace.out

Extract Dynamic Features

 We focus on the samples' interaction with: - Network, file system, registry and process sub-system

12

Malware Classification
Problem: Given an unknown sample, determine if it is malicious Types of ML: Supervised/Unsupervised · Steps:
1. Train the model using a set of known files 2. Use the generated model to classify an unknown file

Extract n Features Label: OK/Malware

Present a label per input

ML ALgorithm

Model

Extract Features

Classifier

Label: Unknown

13

Malware Classification (cont.)
The classifier module uses two supervised approaches:  Association Rules Mining/Learning (primary)  Naïve Bayes (optional-backup)
Note: We may reduce the number of classifiers to one once we have identified the best performing sample
14

Association rule learning

Is a method for discovering relations between variables in large databases.

{

}=>{ }

Rakesh Agrawal et al. introduced association rules for discovering regularities between products sold in supermarkets.

15

Naïve Bayes Classification
A simple probabilistic classifier based on an assumption of strong independence of features.
Uses a supervised learning approach (you need to tell it what's good and what's bad) ­ pick your samples well.
16

Feature Selection

 We use a combination of features extracted during the static and dynamic analysis phase
 The table shows a selection of some of the features used  The last sample is actually Internet Explorer.exe

Static Features

Dynamic Features

Label

Size 65K

Entropy 7.8

Packed Yes

Type of Packer

Network Download/Data Exfil

Mod UPX Yes

File System Modificati on
Yes

Registr y Modific ation
Yes

Persisten ce
Yes

Process Creation/ Tamperin g
Yes

Malicious

794K 5.2

No

MSVC++ Yes

Yes

Yes

No

No

Benign

17

Feature Selection: Call Hashing
Based on the technique explained here https://www.mandiant.com/blog/tracking-malware-importhashing/ It may be difficult to reliably use import hashes with packed/obfuscated malware or when various APIs are used just to defeat emulators.
18

Feature Selection: (Dynamic) Call Hashing
We are hashing only functions that are actually called/used by the program with or without their parameters.
Different hashes for different groups of APIs e.g.:
- Group1: CreateFile, ReadFile, WriteFile, CloseHandle - Group 2: InternetOpen, InternetConnect, InternetSetOption,
HttpSendRequest ... - Group N: RtlInitString, strcpy, strlen, strcmp
19

Feature Selection: (Dynamic) Call Hashing

...

APICall: lstrlenA(m***i.com) APICall: lstrlenA(http://%s) 1

APICall: InternetOpenA APICall: InternetConnectA(m***i.com) 2

APICall: RegCreateKeyExA(Software\Microsoft\windows\CurrentVersion\Internet

Settings\Connections)

3

APICall: lstrlenA(POST)

APICall: lstrlenA(HTTP/1.1) APICall: lstrlenA(h***i.net) 1

APICall: lstrlenA(http://%s)

APICall: InternetConnectA(h***i.net) 2 APICall: lstrlenA(POST) APICall: lstrlenA(HTTP/1.1) 1

...

20

Visualisation
21
Visualisation
Problem: reading raw assembler trace data is necessary but time-consuming We currently have more information than we know what to do with. Visualisation can help BUT you need to ensure that the method suits the data set
22

Visualisation: Previous Work
VeraTrace ­ Danny Quist ­ provides a graph based view of code execution. Visualisation of complex decryption. http://www.offensivecomputing.net/?q=node/1687
23
Visualisation: Previous Work
CantorDust ­ Recon 2013 ­ allows searching for image patterns instead of code patterns. https://sites.google.com/site/xxcantorxdustxx/about
24

Visualisation: PinTool
Determine memory regions written ­ useful for decryption/deobfucation loops.
if (INS_IsMemoryWrite(ins)) { INS_InsertPredicatedCall( ins, IPOINT_BEFORE, (AFUNPTR)RecordMemWrite, IARG_MEMORYWRITE_EA, IARG_MEMORYWRITE_SIZE, IARG_END); }
... VOID RecordMemWrite(VOID * addr, UINT32 size) {
if ( size == 1 ) { //---> detect byte decryption loops MemWriteToVFS(0, (unsigned char *)addr, size, s_addr);
25
Visualisation: Gephi
26

Visualisation: IDA
The instruction that writes to all memory locations

Check buffer_index if it reached the src/dst_buffer length arg_8 ­ src/dst_buffer eax ­ src/dst_buffer[buffer_index]
eax ­ key[key_index] ecx ­ src/dst_buffer[buffer_index] src/dst_buffer[buffer_index] ^= key[key_index] rcx ­ buffer_index rdx ­ src/dst_buffer al ­ decrypted character
27

Visualisation: PIN Trace Viewer

28

Visualisation: PIN Trace Viewer
29
Visualisation: PIN Trace Viewer
30

Guess what's next... 
31
IOC extractor
Other things that we can do with the PIN plugin.
Our PIN plugin extracts API calls along with parameters. Why not just convert that to the Open IOC format ?!
32

IOC extractor
Not so simple, we have a lot of information and not all is actually malicious, so we're doing a filtering with several types of white lists: - clean/not so useful APIs
e.g.: GetModuleHandle, LoadLibraryA
- clean files
e.g.: all the files in a known clean VM image and that aren't changed
- artefacts to ignore
e.q.: environment variables like: ALLUSERSPROFILE=C:\ProgramData APPDATA=C:\Users SystemRoot=C:\Windows
33
IOC extractor
Besides whitelists we are filtering the API parameters to include only relevant content: - we have regexes that are looking for executable files, archives, registry keys, URLs, IP addresses, etc.
- we match APIs to various items from the Open IOC schema.
34

IOC extractor
Example: CopyFile, CreateFileA, CreateFileW, ...
<iocterm term-source="application/vnd.mandiant.mir" display-type="string"
text="FileItem/FullPath" title="File Full Path" data-type="xs:string" />
<IndicatorItem id="" condition="matches" preserve-case="false" negate="false">
<Context document="FileItem" search="FileItem/FullPath" type="mir"></Context> <Content type="string">$api_arg</Content>
</IndicatorItem>
35
yara
Multi-platform pattern matching Swiss-army knife for malware researchers (and everyone else). It is used to identify and classify malware samples. More details here: http://plusvic.github.io/yara/
36

yara
We can use the events recorded by our PIN tool to create yara rules. Example: private rule IsPE {
condition: uint16(0) == 0x5A4D and uint32(uint32(0x3C)) == 0x00004550
} rule Trojan.Autom.1 {
strings: $s0 = /Mozilla\/4\.0 \(compatible; MSIE 6\.0; Windows NT 5\.1\)/ $s1 = /Mozilla\/4\.0 \(compatible; MSIE 6\.0; Windows NT 5\.1\)/ wide $s2 = /http:\/\/users\.***\.com\/fcg-bin\/cgi_get_portrait\.fcg?uins=/ $s3 = /http:\/\/users\.***\.com\/fcg-bin\/cgi_get_portrait\.fcg?uins=/ wide
condition: IsPE and any of ($s*)
}
37
snort
Network Intrusion Detection System (NIDS) mode.
The alerts that are generated will not contain any values that may be system dependent. Example: alert tcp any any -> any any (msg:"potential malicious traffic http://users.***.com/fcgbin/cgi_get_portrait.fcg?uins=211284131"; content:"/fcgbin/cgi_get_portrait.fcg?uins="; content:"User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)" content:"Host: users.***.com"; sid:10000001;)
38

How all ties together
 Perform static and dynamic analysis on a sample  Classify it  If malicious then generate a signature for it

Dynamic Analysis
St ati c Analysis

Dynamic Features Classifiy
Static Features

Malicious ?

Yes

Signature Extraction

No Ignore/Whitelist

39

DEMO: IOC
DEMO

40

DEMO: snort
DEMO
41
Next steps
42

Q & A

Thank you

andreisa@microsoft.com

jacolema@microsoft.com
43

