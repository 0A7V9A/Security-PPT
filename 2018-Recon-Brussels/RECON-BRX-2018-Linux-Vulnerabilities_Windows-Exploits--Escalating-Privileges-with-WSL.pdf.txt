LINUX VULNERABILITIES, WINDOWS EXPLOITS
Escalating Privileges with WSL
Saar Amar Recon brx 2018

WHO AM I?

Saar Amar

Security Researcher

Pasten CTF team member

@AmarSaar

saaramar

OUTLINE
World's quickest intro to WSL Vulnerability
· Demo Exploit
· Problems · Primitives · Shaping the PagedPool · Defeating KASLR · Disabling SMEP Demo (not really surprising...)

WSL
Windows Subsystem for Linux Introduced in Windows 10 Lets you execute Linux binaries natively on Windows lxcore.sys implements all the functionality that a Linux application will expect
· Some parts from scratch (pipes) · Some parts just are just wrappers around NT kernel API
Interested? Check out Alex Ionescu's talk at Blackhat 2016
· http://www.alex-ionescu.com/publications/BlackHat/blackhat2016.pdf

WAIT JUST A SEC...
So... you want to tell me there is a whole new driver...
· which implements tons of functionality
· Does a lot of parsing · Accessible from low-privileged users · And you really expect me not to reverse it!?

CVE-2018-0743
· OK, so one weekend I wake up, trying to understand some logic at lxcore
· Reversing... and suddenly I see an odd behavior where the driver reads an array of strings from userspace
· AKA lxcore!LxpUtilReadUserStringSet

lxcore!LxpUtilReadUserStringSet
Allocates a buffer on the PagedPool, used to hold the strings in the following format:

THE VULNERABILITY
Let's look at the calculation of the allocation size:
· Many integer overflow checks, but one is missing... · Nothing checks overflow on 0x18 * argc (v_metadataArrSize)! · And v_metadataArrSize is UINT32 · 2**32 / 0x18 == 0xaaaaaaa, so in this case v_metadataArrSize will end up 0 · The function will later fill these metadata structs out-of-bounds

THE VULNERABILITY
So how does it look like?

TRIGGERING THE VULNERABILITY

DEMO
POC TO PANIC

LET THE FUN BEGIN

MOTIVATION
"Before we get started, though, it's worth briefly noting why there is so much value in writing an exploit. Finding and eliminating bugs obviously improves software correctness, but writing exploits is always a significant learning opportunity. Throughout the history of the security industry, there's a long track record of offense driving defense, leading to technologies such as stack canaries, NX support in processors and ASLR."
Chris Evans

RESTRICTIONS
The corruption is a 32-bit wildcopy (4GB kernel memory overwrite) · Kernel crashed on a write to an unmapped page, which means we don't natively control any interesting data in use · Panic is 0x50, PAGE_FAULT_IN_NONPAGED_AREA
The content I corrupt with is not totally under my control

RESTRICTIONS
I can (partially) control the allocation size, but it has to be >= 0xaaaaaab (which means chunk size 0xaaab000)
· Remember, there is an int overflow check over the addition!
... ...
size = sizeof(str_hdr_s) * argc + totalStrsLengths

STOPPING WILDCOPIES
This isn't the first wildcopy exploit, so there are some known methods Race the kernel on context switch between processes
· Need to execute code in time, and stop the wildcopy "cleanly" · Downside: can be extremely unstable
Stagefright style: corrupt a function pointer that is called by definition while the copy occurs
· We're not lucky enough to have one of these in our case
Find a really cool and amazing trick, which is 100% reliable
· Mm...let's do that 

DOUBLE FETCH
Remember I told you there is a double-fetch in my function?
· Read strings to calculate the sum of their lengths · Allocate a huge chunk · Copy the strings again from userspace into the chunk
THERE IS NO DOUBLE FETCH VULNERABILITY HERE
· Again guys, really, there isn't
They check against the total length that there is no corruption But... We don't need a corruption, we just need to make the copy loop stop!

STOPPING THE WILDCOPY
Execve just reads argv until it reaches NULL (it doesn't get argc)

WINDOWS POOLS 101
ExAllocatePoolWithTag(pooltype, size, tag, ...)
· roundup(size, 0x10) · size < 0x200: lookasides && freelists · 0x200 <= size < page: freelists · size >= page: bitmap, lower page available, paged aligned
When you free a chunk, it goes to the freelist's head For example, to allocate 0x7d00:
· the pool allocates 0x8000 · returns 0x7d00 to caller · inserts the remainder to the freelist's tail
For more information, see Tarjei Mandt's presentation:
https://media.blackhat.com/bh-dc-11/Mandt/BlackHat_DC_2011_Mandt_kernelpool-Slides.pdf

SHAPE

SHAPE

SHAPE

SHAPE

SHAPE
But, I don't have such big allocation primitive
· I can reach ~0x100000...but not 0x15560000
And if we spray with the "little" ones, until I free them all, some will be paged out
· Again, PagedPool, it's not fs/networking/etc
So... need to find a larger allocation primitive fcntl with F_SETPIPE_SZ, ring buffers!
· Can reach 0x2000000, 0x4000000
Spray with that, and...

NEXT LEVEL!

KERNEL VS USER?
OK! Finally, we have a good panic Now, just choose what struct to target in our shape, and exploit its logic to execute code Two trivial options:
· Kernel ­ execute code from kernel VAS
· Find the PTE (randomized in Anniversary) · Turnoff the NX bit
· User ­ execute code from user VAS
· There is no SMAP by design (easy to fake structs) · We control everything ­ content, protection, etc · Need to disable SMEP (cr4.bit20 &= ~(1<<20))
BTW, either ways won't work with VSM (EPT and MBEC)
· Kudos to MSFT's team for this mitigation!

PRIMITIVES
Well, usually I build myself a nice relative/arbitrary read/write But even if we find the perfect struct
· We corrupt with the struct
· And the pointer is paged out after the corruption...
But wait... str_len can be mapped as a user address!

SHM
You know it!
· shmget, shmat, shmctl
shmget() calls ExAllocatePoolWithTag on the PagedPool And at the flow of shmat() we have:
· shm->file->ops->map()

DEMO
jump to userspace code, 0xfc KeBugCheck

ROP?
So we need to disable SMEP before calling userspace
· Usually done with ROP
shm->file is now in userspace memory, and it remains there Result: we can call arbitrary kernel functions (as many times as we want)
· Step 1: set shm->file->ops->map, which is in our process's memory, to the kernel function address
· Step 2: call the syscall shmat, which will fail but will also call the target
Unlike ROP, our functions/gadgets should return with the same rsp In reality, first call will disable SMEP, second one will be our shellcode

INFOLEAK
Go over all the writes to userspace Need to choose a good struct for that
· Arbitrary / relative read
· Arbitrary is great for <Creators, just read the HAL HEAP · After Creators, relative read is the best
Ideally, leak from a shm struct
· Best: from the very SAME shm we corrupted · Keeps the shape simple

ARBITRARY READ
Great, from the shmctl IPC_STAT, it's easy to leak PagedPool addresses
· our corruption writes PagedPool pointers over the shm struct · read the overwritten fields with IPC_STAT
We can use the same trick for an (almost) arbitrary read:
· corrupt the next field of the shm struct to point to userspace · point the next field of the userspace shm to the target kernel address · call shmctl(IPC_STAT) to dereference!
(we have to know a single uint16 for the shmid)

ARBITRARY READ

HOWTO?
Shape the PagedPool
· Create huge workspace with following pages, and remaining SHM struct · Make sure to create holes before the workspace
Free the workspace fork()
· One thread triggers the vulnerability · Second thread stops the wildcopy
Use arbitrary reads (through shmctl()), leak ntos base address Call shmat(), trigger func pointer call PROFIT

FINAL DEMO

THE END
Shoutouts!
· To the great folks at the MSRC! · Matt Graeber · Tomer Schwartz
· Recon brx 2018 team!
Slides, Video, full exploit:
· https://github.com/saaramar/execve_exploit · https://www.youtube.com/watch?v=3deJvbBHET4&feature=youtu.be
Follow me on twitter: @AmarSaar NEVER STOP REVERSEING AND EXPLOITING

Questions?

Thank you ; )

